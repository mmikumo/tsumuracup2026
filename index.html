<!DOCTYPE html>
<html lang="ja">
<head>
  <!--
    簡易README（このファイルの先頭コメント）
    ----------------------------------------
    ■ 目的
      ・新春イベント向けスマホブラウザゲームの土台です。
      ・HTML/CSS/JS のみで動作し、ローカルで index.html を開くだけで遊べます。

    ■ 差し替えポイント（★ここを変更 を検索）
      ・画像：assets/logo/game_logo.png、assets/haikei/sora.png、assets/haikei/jimen.png、assets/haikei/saku.png、assets/haikei/select.png、assets/haikei/crown1.png、assets/haikei/crown2.png、assets/haikei/crown3.png、assets/haikei/cancel.png、assets/horses/*.png（silhouette.png を未選択用に使用）、assets/horse-names/*.png、assets/result-names/*.png、assets/race/yosou.png、assets/race/goal.png、assets/race/tekichu.png、assets/banners/banner_tsumura_kogei.png、assets/banners/banner_tsumura_module.png
      ・テキスト：タイトル文言、馬説明など
      ・データ：script.js の horses 配列
      ・定数：script.js 冒頭の速度や演出調整用定数

    ■ 主要定数（script.js 冒頭で宣言）
      BASE_SPEED / SPEED_UP_MULTIPLIER / SPEED_UP_DURATION_MS / COUNTDOWN_INTERVAL_MS /
      STAGE_RATIO_W / STAGE_RATIO_H / STAGE_MIN_W / STAGE_BASE_W / STAGE_MAX_W
      それぞれ背景速度、加速倍率、加速時間、カウントダウン間隔、ステージ幅調整に使用。
      VIRTUAL_BASE_WIDTH / VIRTUAL_BASE_HEIGHT は仮想画面サイズで、ウィンドウに合わせて全体を等比スケールします。

    ■ テスト手順（受け入れテストの流れ）
      1. タイトルで「ゲームで遊ぶ」を押し、予想画面に遷移する。
      2. 9頭から 1→2→3 位を順に選び、選び直しも試す。
      3. レース開始でカウントダウン、SPEED UP、追い抜き演出を確認する。
      4. リザルトで予想通りの順位が表示されることを確認する。
      5. スクロールしてバナーが表示されること、画面サイズを変えてもゲーム全体が中央に収まり比率が保たれることを確認する。

    ■ 読み方のガイド
      1. HTML の各セクション構造 →
      2. script.js の定数宣言とデータ →
      3. 画面遷移ロジック（screenManager 周辺） →
      4. レース演出（raceController）
      の順に読むと理解がしやすい構成です。
  -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>つむら杯 新春レース（仮）</title>
  <style>
:root {
  --color-bg-stripe-a: #bfe5ff;
  --color-bg-stripe-b: #d9f1ff;
  --color-stage-border: #1f5ed2;
  --color-stage-white: #ffffff;
  --color-stage-stripe-light: #fff6c5;
  --color-stage-stripe-dark: #ffe27a;
  --color-stage-field: #a6f0bb;
  --color-stage-shadow: rgba(30, 73, 160, 0.18);
  --color-text-main: #1f315f;
  --color-text-strong: #0e2660;
  --color-text-muted: #55729f;
  --color-button-blue-top: #59b4ff;
  --color-button-blue-bottom: #1f73f2;
  --color-button-yellow-top: #ffd95f;
  --color-button-yellow-bottom: #f5a623;
  --color-button-pink-top: #ff7fc7;
  --color-button-pink-bottom: #ff4592;
  --color-button-shadow: rgba(23, 74, 160, 0.28);
  --color-ghost-border: #2a63d6;
  --color-ghost-bg: rgba(255, 255, 255, 0.75);
  --transition-fast: 180ms ease-out;
  --transition-cta: 120ms ease-out;
  --stage-ratio-w: 705;
  --stage-ratio-h: 900;
  --stage-width: 705px;
  --stage-actual-width: var(--stage-width);
  --stage-actual-height: calc(
    var(--stage-actual-width, var(--stage-width)) * var(--stage-ratio-h) /
      var(--stage-ratio-w)
  );
  --stage-scale-factor: 1;
  --game-scale: 1;
  --stage-base-height: 900;
  --stage-bg-ground-height: 599;
  --stage-bg-sky-height: 304;
  --stage-bg-bloom-height: 55;
  --title-logo-height: 451;
  --goal-gate-height: 223;
  --runner-height: 130;
  --prediction-panel-height: 129;
  --prediction-panel-width: 688;
  --prediction-name-height: 160;
  --prediction-horse-height: 71;
  --selection-crown-height: 52;
  --selection-silhouette-height: 83;
  --selection-cancel-width: 61;
  --selection-cancel-height: 37;
  --select-grid-horse-height: 106;
  --race-tekichu-offset: 12;
  --cta-height-multiplier: 0.14;
  --race-panel-aspect: 1;
  font-size: 16px;
}

* {
  box-sizing: border-box;
}

html,
body {
  height: 100%;
  overflow: hidden;
}

body {
  margin: 0;
  --cta-height: max(28px, calc(var(--stage-width) * var(--cta-height-multiplier)));
  font-family: 'Segoe UI', 'Hiragino Kaku Gothic ProN', 'Yu Gothic', sans-serif;
  color: var(--color-text-main);
  background: #000;
}

.margin-bands {
  position: fixed;
  inset: 0;
  background: repeating-linear-gradient(
    90deg,
    var(--color-bg-stripe-a) 0px,
    var(--color-bg-stripe-a) 100px,
    var(--color-bg-stripe-b) 100px,
    var(--color-bg-stripe-b) 200px
  );
  z-index: 0;
  pointer-events: none;
}

.game-viewport {
  position: fixed;
  inset: 0;
  padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom)
    env(safe-area-inset-left);
  display: grid !important;
  place-items: center !important;
  overflow: hidden;
  z-index: 1;
  overscroll-behavior: none;
}

.game-canvas {
  position: relative;
  width: 750px;
  height: 1624px;
  transform: scale(var(--game-scale, 1));
  transform-origin: center center;
  display: flex;
  flex-direction: column;
  align-items: center;
  will-change: transform;
  touch-action: none;
}

.page-header {
  height: 0;
  overflow: hidden;
}

.logo-placeholder {
  display: none;
}

.app {
  flex: 1;
  width: 100%;
  height: 100%;
  min-height: 100%;
  display: grid;
  grid-template-rows: 1fr auto;
  justify-items: center;
  align-items: center;
  row-gap: 32px;
  padding: 0;
  position: relative;
  overflow: hidden;
}

.stage-wrapper {
  width: min(100%, var(--stage-width));
  max-width: 900px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 24px;
  padding: 0;
  align-self: center;
  justify-self: center;
}

.stage {
  width: 100%;
  aspect-ratio: calc(var(--stage-ratio-w) / var(--stage-ratio-h));
  background: var(--color-stage-white);
  border: calc(4px * var(--stage-scale-factor)) solid var(--color-stage-border);
  box-shadow: 0 calc(18px * var(--stage-scale-factor)) calc(34px * var(--stage-scale-factor)) var(--color-stage-shadow),
    0 calc(6px * var(--stage-scale-factor)) calc(12px * var(--stage-scale-factor)) rgba(0, 0, 0, 0.08);
  position: relative;
  overflow: hidden;
}

.stage::before,
.stage::after {
  content: '';
  position: absolute;
  left: 0;
  right: 0;
  z-index: 0;
}

.stage::before {
  top: 0;
  height: 45%;
  background: repeating-linear-gradient(
    45deg,
    var(--color-stage-stripe-light) 0px,
    var(--color-stage-stripe-light) calc(14px * var(--stage-scale-factor)),
    var(--color-stage-stripe-dark) calc(14px * var(--stage-scale-factor)),
    var(--color-stage-stripe-dark) calc(28px * var(--stage-scale-factor))
  );
  border-bottom: calc(4px * var(--stage-scale-factor)) solid rgba(255, 255, 255, 0.8);
}

.stage::after {
  bottom: 0;
  height: 38%;
  background: var(--color-stage-field);
  border-top: calc(4px * var(--stage-scale-factor)) solid rgba(255, 255, 255, 0.8);
}

.app[data-screen='result'] .stage::before,
.app[data-screen='result'] .stage::after {
  opacity: 0;
}

.app[data-screen='title'] .stage::before,
.app[data-screen='title'] .stage::after {
  opacity: 0;
}

.app[data-screen='race'] .stage::before,
.app[data-screen='race'] .stage::after {
  opacity: 0;
}

.app[data-screen='predict'] .stage::before,
.app[data-screen='predict'] .stage::after {
  opacity: 0;
}

.screen {
  position: absolute;
  inset: 0;
  padding: calc(16px * var(--stage-scale-factor)) calc(18px * var(--stage-scale-factor));
  display: flex;
  flex-direction: column;
  gap: 16px;
  opacity: 0;
  pointer-events: none;
  transition: opacity var(--transition-fast);
  z-index: 1;
}

.screen.is-active {
  opacity: 1;
  pointer-events: auto;
}

.screen.is-leaving {
  opacity: 0;
}

.screen-title {
  padding: 0;
}

.screen-predict {
  padding: 0;
}

.screen-race {
  padding: 0;
}

button {
  cursor: pointer;
  font: inherit;
}

.cta-button {
  --cta-top: var(--color-button-blue-top);
  --cta-bottom: var(--color-button-blue-bottom);
  background: linear-gradient(180deg, var(--cta-top) 0%, var(--cta-bottom) 100%);
  color: #ffffff;
  border: 4px solid #ffffff;
  border-radius: 18px;
  font-weight: 800;
  letter-spacing: 0.08em;
  text-align: center;
  padding: 0 32px;
  min-height: var(--cta-height);
  box-shadow: 0 18px 0 rgba(0, 56, 155, 0.14), 0 20px 32px var(--color-button-shadow);
  transition: transform var(--transition-cta), box-shadow var(--transition-cta);
}

.cta-button:disabled {
  opacity: 0.6;
  pointer-events: none;
}

.cta-button:active {
  transform: scale(0.98);
  box-shadow: 0 10px 16px rgba(0, 56, 155, 0.22);
}

.cta-button:hover {
  transform: translateY(-2px);
}

.icon-button {
  width: var(--cta-height);
  min-height: var(--cta-height);
  border-radius: 18px;
  border: 4px solid #ffffff;
  background: linear-gradient(180deg, #fff48d 0%, #ffc93a 100%);
  color: var(--color-text-strong);
  font-weight: 800;
  font-size: 1.6rem;
  box-shadow: 0 12px 0 rgba(217, 160, 34, 0.18), 0 18px 28px rgba(217, 160, 34, 0.24);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: transform var(--transition-cta), box-shadow var(--transition-cta);
}

.icon-button:active {
  transform: scale(0.98);
  box-shadow: 0 8px 16px rgba(217, 160, 34, 0.2);
}

.icon-button:hover {
  transform: translateY(-2px);
}

.ghost-button {
  background: var(--color-ghost-bg);
  border: 3px solid var(--color-ghost-border);
  border-radius: 16px;
  color: var(--color-text-strong);
  font-weight: 700;
  padding: 0 16px;
  min-height: calc(var(--cta-height) * 0.6);
  box-shadow: inset 0 -4px 0 rgba(42, 99, 214, 0.12);
  transition: transform var(--transition-cta), box-shadow var(--transition-cta);
}

.ghost-button:active {
  transform: scale(0.98);
  box-shadow: inset 0 -2px 0 rgba(42, 99, 214, 0.16);
}

.stage-controls {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
  min-height: var(--controls-max-height, auto);
  position: relative;
}

.control-group {
  display: none;
  width: 100%;
  max-width: var(--stage-width);
  flex-direction: column;
  gap: 12px;
  align-items: center;
  margin: 0 auto;
}

.control-group.is-active {
  display: flex;
}

.control-group.is-measuring {
  display: flex !important;
  position: absolute !important;
  visibility: hidden;
  pointer-events: none;
  left: 0;
  right: 0;
  width: 100%;
  top: 0;
}

.control-group--title {
  flex-direction: row;
  align-items: center;
  justify-content: center;
  gap: 12px;
  width: 100%;
}

.control-group--title .cta-button {
  flex: 1;
}

.control-group--predict .cta-button {
  width: 100%;
}

.control-group--race .cta-button {
  --cta-top: var(--color-button-yellow-top);
  --cta-bottom: var(--color-button-yellow-bottom);
  font-size: 1.8rem;
  width: 100%;
}

.control-group--result .cta-button {
  --cta-top: var(--color-button-pink-top);
  --cta-bottom: var(--color-button-pink-bottom);
  width: 100%;
}

.control-row {
  display: flex;
  gap: 12px;
  width: 100%;
  justify-content: center;
}

.control-row .ghost-button {
  flex: 1;
  max-width: 50%;
}

body.is-compact {
  --cta-height-multiplier: 0.11;
}

body.is-compact .stage-wrapper {
  gap: 14px;
  padding: 16px 0;
}

body.is-compact .stage-controls {
  gap: 10px;
}

body.is-compact .control-group {
  gap: 6px;
}

body.is-compact .control-row {
  flex-wrap: wrap;
  gap: 8px;
}

body.is-compact .control-row .ghost-button {
  max-width: 100%;
  flex: 1 1 100%;
}

body.is-compact .cta-button {
  font-size: 1.1rem;
  padding: 0 20px;
}

body.is-compact .icon-button {
  font-size: 1.3rem;
  width: calc(var(--cta-height) * 0.9);
}

body.is-compact .ghost-button {
  font-size: 0.8rem;
  padding-inline: 12px;
}

body.is-compact .title-logo-frame {
  width: min(88%, 420px);
}

.title-stage {
  position: relative;
  margin: auto;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  flex: 1;
}


.title-backdrop {
  position: absolute;
  inset: 0;
  overflow: hidden;
  border-radius: inherit;
  z-index: 0;
}

.title-layer {
  position: absolute;
  left: 0;
  width: 100%;
  background-repeat: repeat-x;
  background-size: auto 100%;
  background-position: 0 0;
  animation-timing-function: linear;
  animation-iteration-count: infinite;
  animation-play-state: paused;
  pointer-events: none;
}

.title-layer--sky {
  top: 0;
  height: calc(var(--stage-scale-factor) * var(--stage-bg-sky-height) * 1px);
  background-image: url('assets/haikei/sora.png');
  background-position: center top;
  animation-name: titleSkyScroll;
  animation-duration: 36s;
  z-index: 0;
}

.title-layer--saku {
  bottom: calc(
    var(--stage-scale-factor) *
      (var(--stage-bg-ground-height) - var(--stage-bg-bloom-height)) * 1px
  );
  height: calc(var(--stage-scale-factor) * var(--stage-bg-bloom-height) * 1px);
  background-image: url('assets/haikei/saku.png');
  background-position: center bottom;
  animation-name: titleGroundScroll;
  animation-duration: 20s;
  z-index: 1;
}

.title-layer--ground {
  bottom: 0;
  height: calc(var(--stage-scale-factor) * var(--stage-bg-ground-height) * 1px);
  background-image: url('assets/haikei/jimen.png');
  background-position: center bottom;
  animation-name: titleGroundScroll;
  animation-duration: 12s;
  z-index: 2;
}

.title-runner-layer {
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 2;
}

.title-runner {
  position: absolute;
  left: calc(100% + 40px);
  height: calc(var(--stage-scale-factor) * var(--runner-height) * 1px);
  animation-name: titleRunnerFlow;
  animation-timing-function: linear;
  animation-iteration-count: infinite;
  will-change: transform;
}

.title-runner img {
  display: block;
  height: 100%;
  width: auto;
}

.title-runner--lane1 {
  top: calc(var(--stage-scale-factor) * 520px);
  animation-duration: 18s;
  animation-delay: -4s;
}

.title-runner--lane2 {
  top: calc(var(--stage-scale-factor) * 560px);
  animation-duration: 20s;
  animation-delay: -9s;
}

.title-runner--lane3 {
  top: calc(var(--stage-scale-factor) * 600px);
  animation-duration: 16s;
  animation-delay: -2s;
}

.title-runner--lane4 {
  top: calc(var(--stage-scale-factor) * 640px);
  animation-duration: 19s;
  animation-delay: -12s;
}

@keyframes titleSkyScroll {
  from {
    background-position: 0 0;
  }
  to {
    background-position: calc(-1 * var(--stage-actual-width, var(--stage-width))) 0;
  }
}

@keyframes titleGroundScroll {
  from {
    background-position: 0 0;
  }
  to {
    background-position: calc(-1 * var(--stage-actual-width, var(--stage-width))) 0;
  }
}

.app[data-screen='title'] .title-layer {
  animation-play-state: running;
}

.title-logo-frame {
  height: calc(var(--stage-scale-factor) * var(--title-logo-height) * 1px);
  max-width: calc(var(--stage-actual-width, var(--stage-width)) * 0.9);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  z-index: 3;
}

.title-logo-img {
  height: 100%;
  width: auto;
  max-width: 100%;
  display: block;
  object-fit: contain;
}

@keyframes titleRunnerFlow {
  from {
    transform: translateX(0);
  }
  to {
    transform: translateX(
      calc(-1 * var(--stage-actual-width, var(--stage-width)) - 320px)
    );
  }
}

.predict-stage {
  position: relative;
  width: 100%;
  height: 100%;
  background: url('assets/haikei/select.png') center / cover no-repeat;
}

.predict-board {
  position: absolute;
  inset: 0;
}

  .predict-preview {
    position: absolute;
    left: calc(var(--stage-scale-factor) * 65px);
    top: calc(var(--stage-scale-factor) * 202px);
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: calc(var(--stage-scale-factor) * 20px);
}

.predict-preview-name {
  height: calc(var(--stage-scale-factor) * var(--prediction-name-height) * 1px);
  width: auto;
  max-width: none;
  object-fit: contain;
  display: block;
}

.predict-selection {
  position: absolute;
  inset: 0;
}

.selection-slots {
  position: absolute;
  inset: 0;
  list-style: none;
  margin: 0;
  padding: 0;
}


.selection-slot {
  position: absolute;
  width: 0;
  height: 0;
}

  .selection-slot[data-rank='0'] {
    left: calc(var(--stage-scale-factor) * 70px);
    top: calc(var(--stage-scale-factor) * 389px);
  }

  .selection-slot[data-rank='1'] {
    left: calc(var(--stage-scale-factor) * 265px);
    top: calc(var(--stage-scale-factor) * 389px);
  }

  .selection-slot[data-rank='2'] {
    left: calc(var(--stage-scale-factor) * 461px);
    top: calc(var(--stage-scale-factor) * 389px);
  }

.slot-crown-img {
  position: absolute;
  top: 0;
  left: 0;
  height: calc(var(--stage-scale-factor) * var(--selection-crown-height) * 1px);
  width: auto;
  object-fit: contain;
}

.slot-clear {
  position: absolute;
  top: calc(var(--stage-scale-factor) * var(--selection-crown-height) * 1px +
      var(--stage-scale-factor) * 5px);
  left: 0;
  width: calc(var(--stage-scale-factor) * var(--selection-cancel-width) * 1px);
  height: calc(var(--stage-scale-factor) * var(--selection-cancel-height) * 1px);
  border: none;
  background: none;
  padding: 0;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.slot-clear img {
  width: 100%;
  height: 100%;
}

.slot-horse {
  position: absolute;
  top: calc(var(--stage-scale-factor) * 5px);
  display: block;
}

.selection-slot[data-rank='0'] .slot-horse {
  left: calc(var(--stage-scale-factor) * 75px);
}

.selection-slot[data-rank='1'] .slot-horse {
  left: calc(var(--stage-scale-factor) * 76px);
}

.selection-slot[data-rank='2'] .slot-horse {
  left: calc(var(--stage-scale-factor) * 76px);
}

.slot-horse-img {
  width: auto;
  height: calc(var(--stage-scale-factor) * var(--selection-silhouette-height) * 1px);
  object-fit: contain;
}

.predict-field {
  position: absolute;
  inset: 0;
}

.horse-grid {
  position: absolute;
  inset: 0;
  display: block;
  list-style: none;
  margin: 0;
  padding: 0;
}

.horse-card {
  position: absolute;
  border: none;
  background: transparent;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  transition: transform var(--transition-cta), filter var(--transition-cta);
  appearance: none;
  transform: translateX(-50%);
}

.horse-card:hover,
.horse-card:focus-visible {
  transform: translateX(-50%) translateY(calc(-4px * var(--stage-scale-factor)));
}

.horse-card:focus-visible {
  outline: calc(3px * var(--stage-scale-factor)) solid var(--color-stage-border);
  outline-offset: calc(4px * var(--stage-scale-factor));
}

.horse-card.is-preview {
  filter: drop-shadow(0 calc(6px * var(--stage-scale-factor)) calc(12px * var(--stage-scale-factor)) rgba(23, 74, 160, 0.3));
}

.horse-thumb {
  width: 100%;
  display: flex;
  align-items: flex-end;
  justify-content: center;
}

.horse-thumb-img {
  width: auto;
  height: calc(var(--stage-scale-factor) * var(--select-grid-horse-height) * 1px);
  object-fit: contain;
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

.badge {
  position: absolute;
  top: calc(8px * var(--stage-scale-factor));
  left: calc(8px * var(--stage-scale-factor));
  width: calc(34px * var(--stage-scale-factor));
  height: calc(34px * var(--stage-scale-factor));
  border-radius: 50%;
  background: #ff5b8b;
  color: #ffffff;
  font-weight: 800;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 calc(6px * var(--stage-scale-factor))
    calc(12px * var(--stage-scale-factor)) rgba(255, 91, 139, 0.3);
}

.race-stage {
  position: relative;
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
}

.race-track {
  position: relative;
  flex: 1;
  overflow: hidden;
  transform-origin: center center;
  transition: transform 420ms ease-out;
  --race-zoom-scale: 1;
  --race-pan-x: 0px;
  --race-pan-y: 0px;
  --race-shake-x: 0px;
  --race-shake-y: 0px;
  transform: translate(var(--race-pan-x), var(--race-pan-y))
    translate(var(--race-shake-x), var(--race-shake-y))
    scale(var(--race-zoom-scale));
  will-change: transform;
}
.race-stage.is-straight-zoom .race-track {
  --race-zoom-scale: 1.05;
}

.race-canvas {
  display: block;
  width: 100%;
  height: 100%;
}

.race-backdrop {
  position: absolute;
  inset: 0;
  pointer-events: none;
  overflow: hidden;
}

.race-layer {
  position: absolute;
  left: 0;
  width: 100%;
  background-repeat: repeat-x;
  background-position: 0 0;
  background-size: auto 100%;
  will-change: background-position;
}

.race-layer--sky {
  top: 0;
  height: calc(var(--stage-scale-factor) * var(--stage-bg-sky-height) * 1px);
  background-image: url('assets/haikei/sora.png');
}

.race-layer--saku {
  bottom: calc(
    var(--stage-scale-factor) *
      (var(--stage-bg-ground-height) - var(--stage-bg-bloom-height)) * 1px
  );
  height: calc(var(--stage-scale-factor) * var(--stage-bg-bloom-height) * 1px);
  background-image: url('assets/haikei/saku.png');
}

.race-layer--ground {
  bottom: 0;
  height: calc(var(--stage-scale-factor) * var(--stage-bg-ground-height) * 1px);
  background-image: url('assets/haikei/jimen.png');
  transition: filter 220ms ease-out;
  filter: blur(var(--race-ground-blur, 0px));
}

.race-lanes {
  position: absolute;
  left: calc(26px * var(--stage-scale-factor));
  right: calc(26px * var(--stage-scale-factor));
  bottom: calc(110px * var(--stage-scale-factor));
  height: calc(
    var(--stage-scale-factor) * (var(--runner-height) + 90) * 1px
  );
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  z-index: 3;
}

.race-lane {
  position: relative;
  height: calc(var(--stage-scale-factor) * (var(--runner-height) + 20) * 1px);
  display: flex;
  align-items: center;
}

.horse-runner {
  position: absolute;
  left: 0;
  height: calc(var(--stage-scale-factor) * var(--runner-height) * 1px);
  will-change: transform;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  transition: opacity 240ms ease-out;
}

.horse-runner img {
  height: 100%;
  width: auto;
  object-fit: contain;
}

.horse-runner .runner-shadow {
  position: absolute;
  bottom: calc(-10px * var(--stage-scale-factor));
  left: 50%;
  transform: translateX(-50%);
  width: calc(var(--stage-scale-factor) * var(--runner-height) * 0.6px);
  height: calc(14px * var(--stage-scale-factor));
  background: radial-gradient(circle, rgba(0, 0, 0, 0.18) 0%, rgba(0, 0, 0, 0) 70%);
  opacity: 0.5;
  filter: blur(calc(2px * var(--stage-scale-factor)));
}

.race-opponents {
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 2;
}

.race-finishers {
  position: absolute;
  left: calc(26px * var(--stage-scale-factor));
  right: calc(26px * var(--stage-scale-factor));
  bottom: calc(26px * var(--stage-scale-factor));
  height: calc(var(--stage-scale-factor) * (var(--runner-height) + 40) * 1px);
  pointer-events: none;
  z-index: 4;
}

.finish-runner {
  position: absolute;
  bottom: 0;
  left: 0;
  width: calc(var(--stage-scale-factor) * var(--runner-height) * 1px);
  height: calc(var(--stage-scale-factor) * var(--runner-height) * 1px);
  display: flex;
  align-items: flex-end;
  justify-content: center;
  opacity: 0;
  animation: finisher-run 1.4s ease-out forwards;
  animation-delay: var(--finish-delay, 0s);
}

.finish-runner img {
  height: 100%;
  width: auto;
  object-fit: contain;
}

.finish-runner::after {
  content: '';
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  bottom: calc(-10px * var(--stage-scale-factor));
  width: calc(var(--stage-scale-factor) * var(--runner-height) * 0.6px);
  height: calc(14px * var(--stage-scale-factor));
  background: radial-gradient(circle, rgba(0, 0, 0, 0.18) 0%, rgba(0, 0, 0, 0) 70%);
  filter: blur(calc(2px * var(--stage-scale-factor)));
}

.opponent-runner {
  position: absolute;
  left: 100%;
  height: calc(var(--stage-scale-factor) * var(--runner-height) * 1px);
  will-change: transform;
  opacity: 0;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  transform: translateX(0);
  transition: opacity 240ms ease-out;
}

.opponent-runner img {
  height: 100%;
  width: auto;
  max-width: 100%;
  object-fit: contain;
}

.opponent-runner.is-hidden {
  opacity: 0;
}

.horse-runner.is-passed,
.horse-runner.is-falling-behind {
  filter: saturate(0.6) brightness(0.9);
  opacity: 0.85;
}

.horse-runner.is-passed::after {
  content: '追い抜き！';
  position: absolute;
  top: calc(-26px * var(--stage-scale-factor));
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255, 255, 255, 0.92);
  color: var(--color-text-strong);
  font-weight: 700;
  font-size: calc(0.65rem * var(--stage-scale-factor));
  padding: calc(2px * var(--stage-scale-factor)) calc(8px * var(--stage-scale-factor));
  border-radius: 999px;
  box-shadow: 0 calc(6px * var(--stage-scale-factor))
    calc(10px * var(--stage-scale-factor)) rgba(0, 0, 0, 0.12);
}

.race-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: center;
  pointer-events: none;
  padding: calc(24px * var(--stage-scale-factor));
  z-index: 5;
}

.countdown {
  font-size: 3rem;
  font-weight: 800;
  color: #ff477b;
  text-shadow: 0 6px 14px rgba(255, 71, 123, 0.3);
}

.speedup-tip {
  font-weight: 700;
  background: rgba(255, 255, 255, 0.85);
  padding: calc(8px * var(--stage-scale-factor)) calc(16px * var(--stage-scale-factor));
  border-radius: 999px;
  color: var(--color-text-strong);
  box-shadow: 0 calc(8px * var(--stage-scale-factor))
    calc(16px * var(--stage-scale-factor)) rgba(0, 0, 0, 0.08);
}
.race-straight-telop {
  position: absolute;
  top: 45%;
  left: 50%;
  font-size: calc(2.6rem * var(--stage-scale-factor));
  font-weight: 800;
  letter-spacing: 0.12em;
  color: #ffffff;
  text-shadow: 0 8px 18px rgba(0, 0, 0, 0.35), 0 0 12px rgba(255, 94, 0, 0.65);
  opacity: 0;
  transform: translate(-50%, -50%) scale(0.96);
  transition: opacity 220ms ease-out, transform 220ms ease-out;
}
.race-straight-telop.is-visible {
  opacity: 1;
  transform: translate(-50%, -50%) scale(1);
}
.race-distance-telop {
  position: absolute;
  top: calc(var(--stage-scale-factor) * 200px);
  left: 50%;
  transform: translate(-50%, -30%) scale(0.9);
  padding: calc(10px * var(--stage-scale-factor))
    calc(24px * var(--stage-scale-factor));
  border-radius: calc(24px * var(--stage-scale-factor));
  font-size: calc(22px * var(--stage-scale-factor));
  font-weight: 800;
  color: #ffffff;
  background: linear-gradient(90deg, rgba(255, 102, 170, 0.92), rgba(255, 59, 59, 0.92));
  box-shadow: 0 calc(12px * var(--stage-scale-factor))
    calc(24px * var(--stage-scale-factor)) rgba(255, 59, 59, 0.25);
  opacity: 0;
  pointer-events: none;
  transition: opacity 200ms ease-out, transform 200ms ease-out;
  z-index: 7;
}
.race-distance-telop[data-distance='100'] {
  background: linear-gradient(90deg, rgba(255, 197, 80, 0.95), rgba(255, 140, 0, 0.95));
  box-shadow: 0 calc(12px * var(--stage-scale-factor))
    calc(24px * var(--stage-scale-factor)) rgba(255, 140, 0, 0.24);
}
.race-distance-telop.is-visible {
  opacity: 1;
  transform: translate(-50%, -50%) scale(1);
}
.race-photo-flash {
  position: absolute;
  inset: 0;
  background: rgba(255, 255, 255, 1);
  opacity: 0;
  pointer-events: none;
  transition: opacity 120ms ease-out;
  mix-blend-mode: screen;
}

.goal-gate {
  position: absolute;
  top: calc(var(--stage-scale-factor) * 170px);
  left: 50%;
  transform: translate(80%, 0);
  height: calc(var(--stage-scale-factor) * var(--goal-gate-height) * 1px);
  max-width: calc(var(--stage-actual-width, var(--stage-width)) * 0.8);
  opacity: 0;
  transition: transform 580ms ease-out, opacity 320ms ease-out;
  pointer-events: none;
  z-index: 4;
}

.goal-gate.is-arriving {
  transform: translate(-50%, 0);
  opacity: 1;
}

.goal-gate-img {
  height: 100%;
  width: auto;
  display: block;
}

.race-prediction-panel {
  position: absolute;
  top: calc(var(--stage-scale-factor) * 17px);
  left: calc(var(--stage-scale-factor) * 18.5px);
  width: calc(var(--stage-scale-factor) * var(--prediction-panel-width) * 1px);
  height: calc(var(--stage-scale-factor) * var(--prediction-panel-height) * 1px);
  pointer-events: none;
  z-index: 6;
}

.race-prediction-bg {
  width: 100%;
  height: 100%;
  display: block;
  object-fit: contain;
}

.race-prediction-list {
  list-style: none;
  margin: 0;
  padding: 0;
  position: absolute;
  inset: 0;
}

.race-prediction-item {
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: calc(var(--stage-scale-factor) * 100px);
  height: calc(var(--stage-scale-factor) * 83px);
}

.race-prediction-item:nth-child(1) {
  left: calc(var(--stage-scale-factor) * 234px);
  top: calc(var(--stage-scale-factor) * 45px);
}

.race-prediction-item:nth-child(2) {
  left: calc(var(--stage-scale-factor) * 389px);
  top: calc(var(--stage-scale-factor) * 45px);
}

.race-prediction-item:nth-child(3) {
  left: calc(var(--stage-scale-factor) * 544px);
  top: calc(var(--stage-scale-factor) * 45px);
}

.race-prediction-horse {
  height: calc(var(--stage-scale-factor) * var(--prediction-horse-height) * 1px);
  width: auto;
  object-fit: contain;
  filter: drop-shadow(0 calc(6px * var(--stage-scale-factor)) calc(10px * var(--stage-scale-factor)) rgba(0, 0, 0, 0.18));
}

.race-tekichu {
  position: absolute;
  top: 50%;
  left: 50%;
  height: calc(var(--stage-scale-factor) * 97px);
  width: auto;
  transform: translate(-50%, -50%) scale(0.7);
  opacity: 0;
  transition: opacity 220ms ease-out;
  pointer-events: none;
  z-index: 2;
}

.race-tekichu.is-visible {
  opacity: 1;
  animation: tekichuPop 420ms ease-out;
}

@keyframes tekichuPop {
  0% {
    transform: translate(-50%, -50%) scale(0.6);
  }
  60% {
    transform: translate(-50%, -50%) scale(1.02);
  }
  100% {
    transform: translate(-50%, -50%) scale(0.9);
  }
}

.horse-runner.is-hidden {
  opacity: 0;
}

@keyframes finisher-run {
  0% {
    transform: translateX(-12%);
    opacity: 0;
  }
  12% {
    opacity: 1;
  }
  100% {
    transform: translateX(140%);
    opacity: 1;
  }
}

.result-stage {
  position: absolute;
  inset: calc(18px * var(--stage-scale-factor));
  background: linear-gradient(180deg, #fff2f8 0%, #ffffff 100%);
  border: calc(6px * var(--stage-scale-factor)) solid #ff6fb5;
  border-radius: calc(28px * var(--stage-scale-factor));
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  gap: calc(20px * var(--stage-scale-factor));
  padding: calc(28px * var(--stage-scale-factor)) calc(24px * var(--stage-scale-factor))
    calc(32px * var(--stage-scale-factor));
  box-shadow: 0 calc(18px * var(--stage-scale-factor))
    calc(32px * var(--stage-scale-factor)) rgba(255, 102, 170, 0.24);
}

.result-title {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  gap: 6px;
}

.result-celebration {
  margin: 0;
  font-size: 1.8rem;
  font-weight: 800;
  color: #ff9d1c;
  text-shadow: 0 4px 10px rgba(255, 157, 28, 0.3);
}

.result-heading {
  margin: 0;
  font-size: 2.4rem;
  font-weight: 900;
  color: #ff2c8a;
  letter-spacing: 0.04em;
  text-shadow: 0 8px 18px rgba(255, 44, 138, 0.28);
}

.result-sub {
  margin: 0;
  font-weight: 600;
  color: var(--color-text-strong);
}

.result-list {
  list-style: none;
  margin: 0;
  padding: 0;
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: calc(14px * var(--stage-scale-factor));
}

.result-item {
  display: grid;
  grid-template-columns: calc(64px * var(--stage-scale-factor))
    calc(80px * var(--stage-scale-factor)) 1fr auto;
  align-items: center;
  gap: calc(12px * var(--stage-scale-factor));
  background: rgba(255, 255, 255, 0.95);
  border-radius: calc(20px * var(--stage-scale-factor));
  padding: calc(12px * var(--stage-scale-factor)) calc(18px * var(--stage-scale-factor));
  box-shadow: inset 0 0 0 calc(3px * var(--stage-scale-factor)) rgba(255, 111, 181, 0.28),
    0 calc(10px * var(--stage-scale-factor)) calc(18px * var(--stage-scale-factor)) rgba(255, 130, 190, 0.18);
  font-weight: 700;
}

.result-crown {
  width: calc(64px * var(--stage-scale-factor));
  height: calc(52px * var(--stage-scale-factor));
  object-fit: contain;
}

.result-horse {
  width: calc(80px * var(--stage-scale-factor));
  height: calc(80px * var(--stage-scale-factor));
  object-fit: contain;
}

.result-name {
  display: flex;
  align-items: center;
  min-height: calc(56px * var(--stage-scale-factor));
  color: var(--color-text-strong);
}

.result-name-img {
  display: block;
  max-width: min(100%, calc(240px * var(--stage-scale-factor)));
  height: auto;
  object-fit: contain;
}

.result-rank {
  font-size: 1.1rem;
  color: #ff2c8a;
  justify-self: end;
}

.banner-section {
  width: min(calc(var(--stage-width) * 0.9), 480px);
  justify-self: center;
  align-self: center;
  padding-bottom: 0;
}

.banner-list {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  gap: 32px;
  align-items: center;
}

.banner-card {
  width: 100%;
  aspect-ratio: calc(var(--stage-ratio-w) / var(--stage-ratio-h));
  background: #ffffff;
  border: 4px solid var(--color-stage-border);
  border-radius: 22px;
  box-shadow: 0 16px 28px rgba(31, 94, 210, 0.16);
  overflow: hidden;
  transform: translateY(60%);
  transition: transform var(--transition-fast);
}

.banner-card img {
  width: 100%;
  display: block;
}

.banner-card p {
  margin: 0;
  padding: 12px 16px;
  font-weight: 600;
  color: var(--color-text-strong);
  background: rgba(255, 255, 255, 0.85);
}

.banner-section:hover .banner-card,
.banner-section:focus-within .banner-card {
  transform: translateY(0);
}

.modal {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
}

.modal.is-hidden {
  opacity: 0;
  pointer-events: none;
}

.modal-content {
  background: #ffffff;
  border-radius: 20px;
  padding: 24px;
  width: min(420px, calc(var(--stage-width) * 0.75));
  position: relative;
  box-shadow: 0 18px 32px rgba(0, 0, 0, 0.2);
}

.modal-close {
  position: absolute;
  top: 12px;
  right: 12px;
  border: none;
  background: transparent;
  font-size: 1.6rem;
  cursor: pointer;
}

.modal-body {
  margin-top: 16px;
  line-height: 1.6;
}

.modal-body ol {
  padding-left: 1.2em;
}

.modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(17, 35, 75, 0.5);
  z-index: 5;
}

.modal-backdrop.is-hidden {
  opacity: 0;
  pointer-events: none;
}

@media (min-width: 768px) {
  .app {
    padding-bottom: 0;
  }

  .stage-controls {
    gap: 16px;
  }

  .control-row {
    gap: 16px;
  }
}

@media (max-width: 360px) {
  .horse-grid {
    gap: calc(10px * var(--stage-scale-factor));
  }
}

@media (prefers-reduced-motion: reduce) {
  .screen,
  .banner-card,
  .cta-button,
  .ghost-button,
  .icon-button {
    transition: none;
  }

  .cta-button:hover,
  .ghost-button:hover,
  .icon-button:hover {
    transform: none;
  }

  .title-layer {
    animation: none;
  }
}
</style>
</head>
<body>
  <div class="margin-bands" aria-hidden="true"></div>
  <div class="game-viewport" id="viewport">
    <div class="game-canvas">
      <header class="page-header" aria-hidden="true">
        <div class="logo-placeholder" aria-hidden="true">LOGO</div>
      </header>

      <main class="app" data-screen="title">
    <div class="stage-wrapper">
      <section class="stage" aria-live="polite">
        <div class="screen screen-title is-active" data-screen-id="title">
          <div class="title-stage">
            <div class="title-backdrop race-backdrop" aria-hidden="true">
              <div class="title-layer race-layer race-layer--sky title-layer--sky"></div>
              <div class="title-layer race-layer race-layer--saku title-layer--saku"></div>
              <div class="title-layer race-layer race-layer--ground title-layer--ground"></div>
            </div>
            <div class="title-runner-layer" aria-hidden="true">
              <div class="title-runner title-runner--lane1">
                <img src="assets/horses/h2.png" alt="">
              </div>
              <div class="title-runner title-runner--lane2">
                <img src="assets/horses/h3.png" alt="">
              </div>
              <div class="title-runner title-runner--lane3">
                <img src="assets/horses/h1.png" alt="">
              </div>
              <div class="title-runner title-runner--lane4">
                <img src="assets/horses/h2.png" alt="">
              </div>
            </div>
            <div class="title-logo-frame">
              <img src="assets/logo/game_logo.png" alt="つむら杯 新春レースのタイトルロゴ" class="title-logo-img"><!-- ★ここを変更：タイトルロゴのファイルパス -->
            </div>
          </div>
        </div>

        <div class="screen screen-predict" data-screen-id="predict" aria-hidden="true">
          <div class="predict-stage">
            <div class="predict-board">
              <section class="predict-preview" aria-live="polite" aria-label="選択中の馬の紹介">
                <div class="predict-preview-frame">
                  <img src="" alt="" class="predict-preview-name" hidden>
                </div>
              </section>
              <section class="predict-selection" aria-label="予想した順位">
                <ol class="selection-slots">
                  <li class="selection-slot" data-rank="0">
                    <img src="assets/haikei/crown1.png" alt="1着の王冠" class="slot-crown-img">
                    <button class="slot-clear" data-remove-rank="0" hidden aria-label="1着の選択を取り消す">
                      <img src="assets/haikei/cancel.png" alt="">
                    </button>
                    <div class="slot-horse">
                      <img src="assets/horses/silhouette.png" alt="未選択のシルエット" class="slot-horse-img">
                    </div>
                    <span class="sr-only">1着の枠</span>
                  </li>
                  <li class="selection-slot" data-rank="1">
                    <img src="assets/haikei/crown2.png" alt="2着の王冠" class="slot-crown-img">
                    <button class="slot-clear" data-remove-rank="1" hidden aria-label="2着の選択を取り消す">
                      <img src="assets/haikei/cancel.png" alt="">
                    </button>
                    <div class="slot-horse">
                      <img src="assets/horses/silhouette.png" alt="未選択のシルエット" class="slot-horse-img">
                    </div>
                    <span class="sr-only">2着の枠</span>
                  </li>
                  <li class="selection-slot" data-rank="2">
                    <img src="assets/haikei/crown3.png" alt="3着の王冠" class="slot-crown-img">
                    <button class="slot-clear" data-remove-rank="2" hidden aria-label="3着の選択を取り消す">
                      <img src="assets/haikei/cancel.png" alt="">
                    </button>
                    <div class="slot-horse">
                      <img src="assets/horses/silhouette.png" alt="未選択のシルエット" class="slot-horse-img">
                    </div>
                    <span class="sr-only">3着の枠</span>
                  </li>
                </ol>
              </section>
            </div>
            <div class="predict-field" role="region" aria-label="予想する馬の一覧">
              <div class="horse-grid" role="list">
                <!-- JavaScriptで馬カードを展開 -->
              </div>
            </div>
          </div>
        </div>

        <div class="screen screen-race" data-screen-id="race" aria-hidden="true">
          <div class="race-stage">
            <div class="race-prediction-panel" aria-label="あなたの予想順位">
              <img src="assets/race/yosou.png" alt="あなたの予想パネル" class="race-prediction-bg"><!-- ★ここを変更：予想パネルの差し替え -->
              <ol class="race-prediction-list"></ol>
            </div>
            <div class="race-overlay">
              <div class="countdown" aria-live="assertive"></div>
              <div class="speedup-tip">SPEED UP で加速！</div>
              <div class="race-straight-telop" aria-hidden="true">直線！</div>
              <div class="race-distance-telop" data-distance="200" aria-hidden="true">残り200m</div>
              <div class="race-distance-telop" data-distance="100" aria-hidden="true">残り100m</div>
              <div class="race-photo-flash" aria-hidden="true"></div>
            </div>
            <div class="race-track">
              <canvas
                class="race-canvas"
                width="705"
                height="900"
                aria-label="レース演出キャンバス"
              ></canvas>
            </div>
          </div>
        </div>

        <div class="screen screen-result" data-screen-id="result" aria-hidden="true">
          <div class="result-stage">
            <div class="result-title">
              <p class="result-celebration">おめでとう！<!-- ★ここを変更：祝福メッセージ --></p>
              <h2 class="result-heading">予想的中！<!-- ★ここを変更：メイン見出し --></h2>
              <p class="result-sub">あなたが選んだ通りの順位でゴールしました。<!-- ★ここを変更：補足テキスト --></p>
            </div>
            <ol class="result-list"></ol>
          </div>
        </div>
      </section>

      <div class="stage-controls" aria-live="polite">
        <div class="control-group control-group--title is-active" data-controls-id="title">
          <button class="icon-button" data-action="openHowTo" aria-label="遊び方を読む" title="遊び方">？</button>
          <button class="cta-button" data-action="toPredict">ゲームで遊ぶ</button>
        </div>
        <div class="control-group control-group--predict" data-controls-id="predict" aria-hidden="true">
          <button class="cta-button cta-button--select" data-action="selectHorse" disabled aria-label="選択中の馬を順位に追加">SELECT</button>
          <div class="control-row">
            <button class="ghost-button" data-action="backToTitle">タイトルへ戻る</button>
            <button class="ghost-button" data-action="clearSelection">選び直す</button>
          </div>
          <button class="cta-button" data-action="startRace" disabled>レーススタート！</button>
        </div>
        <div class="control-group control-group--race" data-controls-id="race" aria-hidden="true">
          <button class="cta-button" data-action="speedUp">SPEED UP</button>
        </div>
        <div class="control-group control-group--result" data-controls-id="result" aria-hidden="true">
          <button class="cta-button" data-action="replay">もう一度遊ぶ</button>
        </div>
      </div>
    </div>

    <section class="banner-section" aria-label="スポンサー情報">
      <ul class="banner-list">
        <li class="banner-card">
          <img src="assets/banners/banner_tsumura_kogei.png" alt="つむら工芸の企業バナー" loading="lazy">
          <p>つむら工芸 新春キャンペーン実施中！<!-- ★ここを変更：バナー説明文 --></p>
        </li>
        <li class="banner-card">
          <img src="assets/banners/banner_tsumura_module.png" alt="TSUMURA MODULE SYSTEM の企業バナー" loading="lazy">
          <p>TSUMURA MODULE SYSTEM からのお知らせ<!-- ★ここを変更：バナー説明文 --></p>
        </li>
      </ul>
    </section>
      </main>

      <div class="modal is-hidden" id="howto-modal" role="dialog" aria-modal="true" aria-labelledby="howto-title">
        <div class="modal-content">
          <h2 id="howto-title">遊び方</h2>
          <button class="modal-close" data-action="closeModal" aria-label="閉じる">×</button>
          <div class="modal-body">
            <ol>
              <li>9頭の中から 1→2→3 位の順で馬を選びます。</li>
              <li>レースで SPEED UP を使って白熱の追い上げを楽しみましょう。</li>
              <li>結果画面であなたの予想を振り返り、もう一度挑戦できます。</li>
            </ol>
          </div>
        </div>
      </div>
      <div class="modal-backdrop is-hidden" data-action="closeModal" aria-hidden="true"></div>
    </div>
  </div>

  <script>
// ---------------------------------------------
// 定数エリア（演出調整はここから行う）
// ---------------------------------------------
// ★ここを変更：速度・演出調整
const BASE_SPEED = 1.2; // 基本速度（背景/他馬）
const SPEED_UP_MULTIPLIER = 1.8; // SPEED UP倍率
const SPEED_UP_DURATION_MS = 800; // 加速時間
const COUNTDOWN_INTERVAL_MS = 700; // カウントダウン間隔
const STAGE_RATIO_W = 705; // ステージ比（横）：仮想解像度基準幅
const STAGE_RATIO_H = 900; // ステージ比（縦）：仮想解像度基準高
const STAGE_MIN_W = 705; // ステージ最小幅（仮想解像度に固定）
const STAGE_BASE_W = 705; // ステージ基準幅
const STAGE_MAX_W = 705; // ステージ最大幅（仮想解像度に固定）
const VIRTUAL_BASE_WIDTH = 750; // 仮想解像度（横幅）
const VIRTUAL_BASE_HEIGHT = 1624; // 仮想解像度（縦幅）
const PREDICTION_TOP_ROW_COUNT = 4; // 予想画面の上段に並べる頭数
const PREDICTION_BOTTOM_ROW_COUNT = 5; // 予想画面の下段に並べる頭数
const PREDICTION_TOP_ROW_BOTTOM_OFFSET = 234; // 上段の馬の足元位置（ステージ下端からの距離）
const PREDICTION_BOTTOM_ROW_BOTTOM_OFFSET = 73; // 下段の馬の足元位置（ステージ下端からの距離）
const PREDICTION_BOTTOM_ROW_EDGE_OFFSET = 25; // 下段の左右を広げるオフセット量
const MAX_SELECTION_RANKS = 3; // 選択できる順位の数（1〜3着）

// レース描画用の仮想解像度と演出用定数
const RACE_VIRTUAL_WIDTH = 750;
const RACE_VIRTUAL_HEIGHT = 1624;
const RACE_STAGE_BASE_HEIGHT = 900;
const RACE_BACKGROUND_GROUND_HEIGHT = 599;
const RACE_BACKGROUND_SKY_HEIGHT = 304;
const RACE_BACKGROUND_BLOOM_HEIGHT = 55;
const RACE_BASE_SPEED_PER_SEC = 220; // 3.67px/frame を 60fps 想定で換算（レース全体をゆったり演出）
const RACE_PARALLAX_SKY = 0.2;
const RACE_PARALLAX_SAKU = 0.45;
const RACE_PARALLAX_GROUND = 1.35; // 地面を馬より速く流すための倍率
const RACE_OTHER_LANES = [560, 640];
const RACE_PASS_MARGIN = 80;
const RACE_GOAL_TARGET_RATIO = 0.5; // ゴール停止位置（ステージ幅に対する割合）
const RACE_GOAL_RELATIVE_BLEND = 1; // ゴール演出時の相対速度補正（1で完全同期）
const RACE_TIMELINE_SCALE = 2.4; // レース全体の時間を約2.4倍に引き伸ばす
const RACE_MIN_RELATIVE_SPEED_PER_SEC = 60; // 地面との差分として確保したい最低相対速度（px/sec換算）
const RACE_CAMERA_HERO_BIAS = 0.18; // ヒーロー寄りにカメラを寄せて押し出し演出を強化
const RACE_SURGE_AMPLITUDE = 0.12; // ランダムな増減幅（スピード揺らぎ）
const RACE_SURGE_FREQUENCY = 0.9; // 揺らぎの周波数（毎秒）
const RACE_SPEEDUP_RELIEF = 0.35; // SPEED UP 中にライバルが受ける減速率
const RACE_SPEEDUP_STRAIGHT_BONUS = 1.15; // 直線以降の追加倍率
const RACE_SPEEDUP_STRAIGHT_RELIEF = 0.5; // 直線での相対的な減速幅
const RACE_MIN_SPEED_FACTOR = 0.62;
const RACE_MAX_SPEED_FACTOR = 1.2;
const RACE_FINISH_OFFSETS = [0, 1.0, 1.6]; // 秒（1着→1秒後→2着→0.6秒後→3着）
const RACE_FINISH_SPEED = 520; // px/秒（仮想解像度基準）
const RACE_SECOND_HOLD_OFFSET = 160; // ヒーローから見た2着馬の待機オフセット（ステージ座標）
const RACE_THIRD_HOLD_OFFSET = 210; // ヒーローから見た3着馬の待機オフセット（ステージ座標）
const RACE_OTHER_PACK_BASE_OFFSET = 150; // 非選択馬の隊列基準オフセット
const RACE_OTHER_PACK_COLUMN_SPACING = 70; // 隊列内の列間隔
const RACE_OTHER_PACK_ROW_SPACING = 28; // 隊列内の列ごとの前後差
const RACE_OTHER_PACK_FOLLOW_RATE = 6; // 隊列維持の追従速度（1秒あたり）
const RACE_OTHER_PASS_DELAY_BASE_MS = 1200; // 非選択馬が隊列を離れる開始ディレイ
const RACE_OTHER_PASS_DELAY_STEP_MS = 900; // 馬ごとの追加ディレイ（行単位）
const RACE_OTHER_PASS_DELAY_COLUMN_MS = 320; // 列ごとの追加ディレイ
const RACE_OTHER_PASS_DELAY_RANDOM_MS = 380; // 揺らぎ
const RACE_OTHER_EXIT_FADE_MS = [220, 320]; // 画面外に抜けた後のフェード時間
const RACE_TEKICHU_SRC = 'assets/race/tekichu.png';
const RACE_STRAIGHT_ZOOM_SCALE = 1 + (RACE_STATE_IMMERSION.straight?.zoom ?? 0);
const RACE_STRAIGHT_ZOOM_DURATION_MS = 600;
const RACE_STRAIGHT_TELOP_DURATION_MS = 1000;
const RACE_STRAIGHT_TELOP_TEXT = '直線！';
const RACE_DISTANCE_MARKER_SPACING = 160;
const RACE_DISTANCE_MARKER_HEIGHT = 150;
const RACE_DISTANCE_MARKER_WIDTH = 8;
const RACE_DISTANCE_MARKER_COLOR = 'rgba(255, 255, 255, 0.7)';
const RACE_DISTANCE_MARKER_BASE = 'rgba(255, 215, 120, 0.45)';
const RACE_PHOTO_LINE_DURATION_MS = 180;
const RACE_PHOTO_FLASH_DURATION_MS = 180;
const RACE_PHOTO_FLASH_MAX_ALPHA = 0.28;

const RACE_CLIMAX_DURATION = 2600;
const RACE_CLIMAX_LEADIN = 180;
const RACE_CLIMAX_ZOOM_FROM = 1.0;
const RACE_CLIMAX_ZOOM_TO = 1.08;
const RACE_CLIMAX_EXTRA_ZOOM = 0.04;
const RACE_CLIMAX_PAN_X = 12;
const RACE_CLIMAX_PULSE_FREQ = { front: 2.2, stalker: 2.6, closer: 3.0 };
const RACE_CLIMAX_PULSE_AMP = { front: 0.03, stalker: 0.05, closer: 0.08 };
const RACE_CLIMAX_FAKE_LEAD_PX = 8;
const RACE_CLIMAX_FAKE_LEAD_TIME = [600, 1000];
const RACE_CLIMAX_CONTENDER_TOTAL = 5;
const RACE_CLIMAX_EXTRA_CONTENDERS = 2;
const RACE_CLIMAX_CONTENDER_STICK_PX = 8;
const RACE_CLIMAX_CONTENDER_FAKE_LEAD = [600, 1000];
const RACE_CLIMAX_HERO_INNER_SHIFT = 10;
const RACE_CLIMAX_RIVAL_OUTER_SHIFT = [4, 10];
const RACE_CLIMAX_DUST_MULTIPLIER = 1.5;
const RACE_CLIMAX_GROUND_BLUR_PX = 0.4;
const RACE_CLIMAX_SHAKE = { amplitude: 1, duration: 120, repeats: 2 };
const RACE_CLIMAX_HERO_BOOST = 0.16;
const RACE_CLIMAX_OTHERS_RELIEF = 0.08;
const RACE_CLIMAX_RELIEF_FADEOUT = 400;
const RACE_CLIMAX_DISTANCE_TOGGLE_200 = 300;
const RACE_CLIMAX_DISTANCE_TOGGLE_100 = 1200;
const RACE_CLIMAX_DISTANCE_DURATION = 600;
const RACE_CLIMAX_VERTICAL_BOB = 2;

const RACE_DUST_BASE_RATE = 18;
const RACE_DUST_MAX = 70;
const RACE_DUST_LIFETIME = [400, 900];
const RACE_DUST_SIZE = [6, 16];

const RACE_STATE_SPEED_FACTORS = {
  intro: 0.72,
  others: 0.88,
  straight: 1.05,
  climax: 1.14,
  third: 1.08,
  second: 1.12,
  lead: 1.14,
  goal: 1.08,
  finish: 0
};

const RACE_PACE_MODIFIERS = {
  intro: { front: 1.0, stalker: 0.95, closer: 0.92 },
  others: { front: 0.98, stalker: 1.0, closer: 1.02 },
  straight: { front: 1.04, stalker: 1.08, closer: 1.12 },
  climax: { front: 1.08, stalker: 1.12, closer: 1.18 },
  third: { front: 1.02, stalker: 1.08, closer: 1.12 },
  second: { front: 1.04, stalker: 1.1, closer: 1.14 },
  lead: { front: 1.02, stalker: 1.06, closer: 1.08 },
  goal: { front: 1.0, stalker: 1.02, closer: 1.05 },
  finish: { front: 1.0, stalker: 1.0, closer: 1.0 }
};

const RACE_STATE_IMMERSION = {
  intro: { zoom: 0, panX: 0, groundBlur: 0, dust: 1, shake: 0 },
  others: { zoom: 0.01, panX: 4, groundBlur: 0.2, dust: 1.1, shake: 0 },
  straight: { zoom: 0.05, panX: 8, groundBlur: 0.25, dust: 1.25, shake: 1 },
  climax: { zoom: 0.08, panX: 12, groundBlur: 0.4, dust: 1.5, shake: 2 },
  third: { zoom: 0.03, panX: 8, groundBlur: 0.22, dust: 1.2, shake: 1 },
  second: { zoom: 0.04, panX: 10, groundBlur: 0.25, dust: 1.25, shake: 1 },
  lead: { zoom: 0.02, panX: 8, groundBlur: 0.2, dust: 1.1, shake: 0 },
  goal: { zoom: 0.015, panX: 6, groundBlur: 0.18, dust: 1.05, shake: 0 },
  finish: { zoom: 0, panX: 0, groundBlur: 0, dust: 1, shake: 0 }
};

const RACE_LEG_TYPES = ['front', 'stalker', 'closer'];

const RACE_STRAIGHT_STATE_KEY = 'straight';

function scaledDuration(baseMs) {
  return Math.round(baseMs * RACE_TIMELINE_SCALE);
}

const RACE_STATE_SEQUENCE = [
  { key: 'intro', duration: scaledDuration(1000) },
  { key: 'others', duration: scaledDuration(3600) },
  { key: 'straight', duration: scaledDuration(1100) },
  { key: 'climax', duration: scaledDuration(RACE_CLIMAX_DURATION) },
  { key: 'third', duration: scaledDuration(1400) },
  { key: 'second', duration: scaledDuration(1400) },
  { key: 'lead', duration: scaledDuration(900) },
  { key: 'goal', duration: scaledDuration(1500) },
  { key: 'finish', duration: scaledDuration(1700) }
];

const RACE_ASSET_PATHS = {
  sky: 'assets/haikei/sora.png',
  bloom: 'assets/haikei/saku.png',
  ground: 'assets/haikei/jimen.png',
  goal: 'assets/race/goal.png'
};

const raceAssetCache = new Map();
let raceAssetPromise = null;

// ★ここを変更：順位王冠の画像（1〜3位の順）
const crownImages = [
  'assets/haikei/crown1.png',
  'assets/haikei/crown2.png',
  'assets/haikei/crown3.png'
];

// ---------------------------------------------
// データ：馬情報（画像差し替えはここ）
// ---------------------------------------------
// ★ここを変更：馬情報（9頭）— img は実ファイルに差し替えやすいパスに
// 透過PNGのサンプル（h1〜h3）は assets/horses/ 配下に配置済み。
// 選択画面の名前プレートは assets/horse-names/ 配下の PNG を参照しています。
// リザルト画面の名前ロゴは assets/result-names/ 配下の PNG を参照しています。
// ★ここを変更：実際の馬イラストが揃ったら img を差し替えてください。
const horses = [
  {
    id: 'h8',
    name: 'テレビオンエア',
    desc: '映像美術部で育成される注目のスピード派',
    img: 'assets/horses/h1.png',
    nameImg: 'assets/horse-names/name_tv.png',
    resultNameImg: 'assets/result-names/result_tv_onair.png'
  },
  {
    id: 'h5',
    name: 'ブタイステージ',
    desc: '総合舞台部で育成される見せ場を作る仕掛け上手',
    img: 'assets/horses/h1.png',
    nameImg: 'assets/horse-names/name_stage.png',
    resultNameImg: 'assets/result-names/result_stage.png'
  },
  {
    id: 'h3',
    name: 'プロモモーション',
    desc: 'プロモーション開発部で育成されるひらめきと脚力で勝負',
    img: 'assets/horses/h3.png',
    nameImg: 'assets/horse-names/name_planning.png',
    resultNameImg: 'assets/result-names/result_promo.png'
  },
  {
    id: 'h4',
    name: 'スペーススター',
    desc: 'スペース開発部で育成される安定感ある持久力',
    img: 'assets/horses/h1.png',
    nameImg: 'assets/horse-names/name_space.png',
    resultNameImg: 'assets/result-names/result_space_star.png'
  },
  {
    id: 'h1',
    name: 'アーキライン',
    desc: '設計管理室で育成される鋭いコース取りの技巧派',
    img: 'assets/horses/h1.png',
    nameImg: 'assets/horse-names/name_archi.png',
    resultNameImg: 'assets/result-names/result_archi_line.png'
  },
  {
    id: 'h2',
    name: 'デザインインパクト',
    desc: 'デザイン室で育成される美しいフォームが持ち味',
    img: 'assets/horses/h2.png',
    nameImg: 'assets/horse-names/name_design.png',
    resultNameImg: 'assets/result-names/result_design.png'
  },
  {
    id: 'h6',
    name: 'トウキョウクラウン',
    desc: '東京事業本部で育成される栄光狙う首都の覇者',
    img: 'assets/horses/h1.png',
    nameImg: 'assets/horse-names/name_tokyo_crown.png',
    resultNameImg: 'assets/result-names/result_tokyo_crown.png'
  },
  {
    id: 'h9',
    name: 'セッツビジュアル',
    desc: '圧倒的な存在感で魅了するカリスマホース',
    img: 'assets/horses/h1.png',
    nameImg: 'assets/horse-names/name_zetsu.png',
    resultNameImg: 'assets/result-names/result_zetsu_visual.png'
  },
  {
    id: 'h7',
    name: 'ツムラエンブレム',
    desc: '管理部で育成されるチームを束ねる要の馬',
    img: 'assets/horses/h1.png',
    nameImg: 'assets/horse-names/name_emblem.png',
    resultNameImg: 'assets/result-names/result_tsumu_emblem.png'
  }
];

// ---------------------------------------------
// DOM 取得（頻出要素はまとめておく）
// ---------------------------------------------
const gameViewport = document.querySelector('.game-viewport');
const gameCanvas = document.querySelector('.game-canvas');
const app = document.querySelector('.app');
const stageWrapper = document.querySelector('.stage-wrapper');
const stage = document.querySelector('.stage');
const stageControls = document.querySelector('.stage-controls');
const screens = document.querySelectorAll('.screen');
const horseGrid = document.querySelector('.horse-grid');
const previewNameImg = document.querySelector('.predict-preview-name');
const selectionSlots = Array.from(document.querySelectorAll('.selection-slot'));
const selectButton = document.querySelector('[data-action="selectHorse"]');
const controlGroups = document.querySelectorAll('.control-group');
const startButton = document.querySelector('[data-action="startRace"]');
const speedButton = document.querySelector('[data-action="speedUp"]');
const resultList = document.querySelector('.result-list');
const countdownEl = document.querySelector('.countdown');
const raceCanvas = document.querySelector('.race-canvas');
const raceTrack = document.querySelector('.race-track');
const raceStageEl = document.querySelector('.race-stage');
const raceStraightTelopEl = document.querySelector('.race-straight-telop');
const racePhotoFlashEl = document.querySelector('.race-photo-flash');
const raceDistanceTelops = {
  200: document.querySelector('.race-distance-telop[data-distance="200"]'),
  100: document.querySelector('.race-distance-telop[data-distance="100"]')
};
const racePredictionPanel = document.querySelector('.race-prediction-panel');
const racePredictionBg = document.querySelector('.race-prediction-bg');
const racePredictionList = document.querySelector('.race-prediction-list');
const racePredictionHorseImgs = [];
const racePredictionTekichuImgs = [];

const howtoModal = document.getElementById('howto-modal');
const backdrop = document.querySelector('.modal-backdrop');

const placeholderHorseSrc = 'assets/horses/silhouette.png'; // ★ここを変更：未選択時のシルエット画像

function createPlaceholderHorse(idSuffix = 'fallback') {
  return {
    id: `placeholder-${idSuffix}`,
    name: '仮ホース',
    desc: 'データ未設定時に表示される仮のホース',
    img: placeholderHorseSrc,
    nameImg: '',
    resultNameImg: ''
  };
}

const slotImages = selectionSlots.map((slot) => slot.querySelector('.slot-horse-img'));
const slotClearButtons = selectionSlots.map((slot) => slot.querySelector('.slot-clear'));

// ---------------------------------------------
// ステート（状態を管理）
// ---------------------------------------------
let currentScreen = 'title';
let selectedOrder = Array(MAX_SELECTION_RANKS).fill(null); // 選択済みの馬IDを順位ごとに格納
let previewHorseId = null; // 現在プレビュー中の馬ID
let currentPreviewCard = null;
let raceController = null; // レース制御クラスのインスタンス
let virtualScale = 1;

// ---------------------------------------------
// 初期化処理（画面ロード時に呼ぶ）
// ---------------------------------------------
initVirtualViewport();
initStageSizing();
initRacePredictionPanelAspect();
renderHorseCards();
resetPreviewPanel();
updateSelectionSlots();
updateSelectButton();
updateStartButton();
updateControls(currentScreen);
setupGlobalListeners();

// ---------------------------------------------
// レイアウト調整：仮想解像度に合わせて全体をスケーリング
// ---------------------------------------------
function initVirtualViewport() {
  applyVirtualScale();
  window.addEventListener('resize', applyVirtualScale);
  window.addEventListener('orientationchange', applyVirtualScale);
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', applyVirtualScale);
  }
}

function applyVirtualScale() {
  if (!gameCanvas || !gameViewport) return;

  const viewportRect = gameViewport.getBoundingClientRect();
  const viewportStyle = window.getComputedStyle(gameViewport);
  const paddingLeft = parseFloat(viewportStyle.paddingLeft) || 0;
  const paddingRight = parseFloat(viewportStyle.paddingRight) || 0;
  const paddingTop = parseFloat(viewportStyle.paddingTop) || 0;
  const paddingBottom = parseFloat(viewportStyle.paddingBottom) || 0;

  const availableWidth = Math.max(
    0,
    viewportRect.width - paddingLeft - paddingRight
  );
  const availableHeight = Math.max(
    0,
    viewportRect.height - paddingTop - paddingBottom
  );

  const rawScale = Math.min(
    availableWidth / VIRTUAL_BASE_WIDTH,
    availableHeight / VIRTUAL_BASE_HEIGHT
  );
  const safeScale = Number.isFinite(rawScale) && rawScale > 0 ? rawScale : 0.01;

  gameCanvas.style.setProperty('--game-scale', safeScale.toFixed(4));

  virtualScale = safeScale;

  requestAnimationFrame(() => {
    syncStageMeasuredSize();
    updateControlsHeight();
  });
}

function toVirtualCoords(clientX, clientY) {
  if (!Number.isFinite(virtualScale) || virtualScale <= 0) {
    return { x: 0, y: 0 };
  }
  const rect = gameCanvas.getBoundingClientRect();
  const x = (clientX - rect.left) / virtualScale;
  const y = (clientY - rect.top) / virtualScale;
  return { x, y };
}

// ---------------------------------------------
// レイアウト調整：ステージサイズを仮想画面幅に合わせて更新
// ---------------------------------------------
function initStageSizing() {
  updateStageSize();
}

function initRacePredictionPanelAspect() {
  if (!racePredictionPanel || !racePredictionBg) return;

  const applyAspectRatio = () => {
    if (!racePredictionBg.naturalWidth || !racePredictionBg.naturalHeight) return;
    const ratio = racePredictionBg.naturalWidth / racePredictionBg.naturalHeight;
    racePredictionPanel.style.setProperty('--race-panel-aspect', ratio.toFixed(4));
  };

  if (racePredictionBg.complete) {
    applyAspectRatio();
  } else {
    racePredictionBg.addEventListener('load', applyAspectRatio, { once: true });
  }
}

function updateStageSize() {
  if (!stageWrapper || !stageControls || !stage) return;

  document.body.classList.remove('is-compact');
  applyStageWidth(STAGE_BASE_W);

  requestAnimationFrame(() => {
    syncStageMeasuredSize();
    updateControlsHeight();
  });
}

function applyStageWidth(width) {
  const root = document.documentElement;
  root.style.setProperty('--stage-width', `${width}px`);
  root.style.setProperty('--stage-ratio-w', STAGE_RATIO_W);
  root.style.setProperty('--stage-ratio-h', STAGE_RATIO_H);
  const scale = width / STAGE_BASE_W;
  root.style.setProperty('--stage-scale-factor', scale.toFixed(4));
}

function syncStageMeasuredSize() {
  if (!stage) return;
  const rect = stage.getBoundingClientRect();
  if (!rect.width) return;
  const root = document.documentElement;
  root.style.setProperty('--stage-actual-width', `${rect.width}px`);
  root.style.setProperty('--stage-actual-height', `${rect.height}px`);
}

function updateControlsHeight() {
  if (!stageControls) return;

  stageControls.style.setProperty('--controls-max-height', '0px');

  let maxHeight = 0;
  controlGroups.forEach((group) => {
    const isActive = group.classList.contains('is-active');
    if (!isActive) {
      group.classList.add('is-measuring');
    }
    const height = group.offsetHeight;
    if (height > maxHeight) {
      maxHeight = height;
    }
    if (!isActive) {
      group.classList.remove('is-measuring');
    }
  });

  const appliedHeight = Math.ceil(maxHeight);
  stageControls.style.setProperty('--controls-max-height', appliedHeight > 0 ? `${appliedHeight}px` : '0px');
}

// ---------------------------------------------
// 馬カード一覧の描画
// ---------------------------------------------
function renderHorseCards() {
  const placements = computeHorsePlacements();

  horses.forEach((horse, index) => {
    const card = document.createElement('button');
    card.type = 'button';
    card.className = 'horse-card';
    card.setAttribute('aria-label', `${horse.name}を選ぶ`);
    card.dataset.horseId = horse.id;

    const placement = placements[index] || { left: 0, bottom: PREDICTION_BOTTOM_ROW_BOTTOM_OFFSET };
    card.style.left = `${placement.left}px`;
    card.style.bottom = `${placement.bottom}px`;
    card.dataset.row = placement.row;
    card.dataset.slotIndex = String(index);

    const thumb = document.createElement('div');
    thumb.className = 'horse-thumb';

    const thumbImg = document.createElement('img');
    thumbImg.className = 'horse-thumb-img';
    thumbImg.src = horse.img;
    thumbImg.alt = `${horse.name}のイラスト`;
    thumbImg.loading = 'lazy';

    thumb.append(thumbImg);
    const srText = document.createElement('span');
    srText.className = 'sr-only';
    srText.textContent = horse.name;

    card.append(thumb, srText);
    horseGrid.append(card);
  });
}

function computeHorsePlacements() {
  const totalExpected = PREDICTION_TOP_ROW_COUNT + PREDICTION_BOTTOM_ROW_COUNT;
  const placements = [];

  const topSpacing = STAGE_RATIO_W / (PREDICTION_TOP_ROW_COUNT + 1);
  const bottomBaseSpacing = STAGE_RATIO_W / (PREDICTION_BOTTOM_ROW_COUNT + 1);
  const bottomFirstCenter = bottomBaseSpacing - PREDICTION_BOTTOM_ROW_EDGE_OFFSET;
  const bottomLastCenter =
    STAGE_RATIO_W - bottomBaseSpacing + PREDICTION_BOTTOM_ROW_EDGE_OFFSET;
  const bottomSpacing =
    PREDICTION_BOTTOM_ROW_COUNT > 1
      ? (bottomLastCenter - bottomFirstCenter) / (PREDICTION_BOTTOM_ROW_COUNT - 1)
      : 0;

  horses.forEach((_, index) => {
    const isTopRow = index < PREDICTION_TOP_ROW_COUNT;
    const rowIndex = isTopRow ? index : index - PREDICTION_TOP_ROW_COUNT;
    const centerX = isTopRow
      ? topSpacing * (rowIndex + 1)
      : bottomFirstCenter + bottomSpacing * rowIndex;
    const bottomOffset = isTopRow
      ? PREDICTION_TOP_ROW_BOTTOM_OFFSET
      : PREDICTION_BOTTOM_ROW_BOTTOM_OFFSET;

    placements.push({
      left: centerX,
      bottom: bottomOffset,
      row: isTopRow ? 'top' : 'bottom'
    });
  });

  if (horses.length !== totalExpected) {
    console.warn(
      '[predict] 予想画面の馬数が想定と異なります。horsePlacementsの並びを調整してください。',
      { expected: totalExpected, actual: horses.length }
    );
  }

  return placements;
}

// ---------------------------------------------
// 共通イベントリスナーをセット
// ---------------------------------------------
function setupGlobalListeners() {
  document.addEventListener('pointerup', handlePointerUp, { passive: true });
  document.addEventListener('keydown', handleKeyDown);
  registerActionFallbacks();
}

function registerActionFallbacks() {
  const fallbackTypes = ['click', 'keydown'];
  fallbackTypes.forEach((type) => {
    document.addEventListener(
      type,
      (event) => {
        const isKeyEvent = type === 'keydown';
        if (isKeyEvent) {
          const key = event.key;
          if (key !== 'Enter' && key !== ' ') {
            return;
          }
        }

        const target = event.target;
        if (!(target instanceof HTMLElement)) return;

        const actionTarget = target.closest('[data-action]');
        if (!(actionTarget instanceof HTMLElement)) return;

        if (actionTarget._handledOnce) {
          return;
        }

        if (isKeyEvent) {
          event.preventDefault();
        }

        const actionName = actionTarget.dataset.action;
        if (!actionName) return;

        try {
          handleAction(actionName, actionTarget);
          actionTarget._handledOnce = true;
          setTimeout(() => {
            actionTarget._handledOnce = false;
          }, 100);
        } catch (error) {
          console.error('fallback action error:', error);
        }
      },
      true
    );
  });
}

function handlePointerUp(event) {
  const target = event.target;
  if (!(target instanceof HTMLElement)) return;

  const virtualPoint = toVirtualCoords(event.clientX, event.clientY);
  event.virtualX = virtualPoint.x;
  event.virtualY = virtualPoint.y;
  event.virtualScale = virtualScale;

  const actionTarget = target.closest('[data-action]');
  if (actionTarget instanceof HTMLElement) {
    const actionName = actionTarget.dataset.action || '';
    handleAction(actionName, actionTarget);
    actionTarget._handledOnce = true;
    setTimeout(() => {
      actionTarget._handledOnce = false;
    }, 100);
    return;
  }

  const horseCard = target.closest('.horse-card');
  if (horseCard) {
    setPreviewHorse(horseCard.dataset.horseId);
    return;
  }

  const removeBtn = target.closest('[data-remove-rank]');
  if (removeBtn) {
    const rank = Number(removeBtn.dataset.removeRank);
    if (!Number.isNaN(rank)) {
      removeSelectionAt(rank);
    }
  }
}

function handleKeyDown(event) {
  if (event.key === 'Enter' || event.key === ' ') {
    const active = document.activeElement;
    if (active instanceof HTMLElement) {
      const actionTarget = active.closest('[data-action]');
      if (actionTarget instanceof HTMLElement) {
        event.preventDefault();
        handleAction(actionTarget.dataset.action || '', actionTarget);
        return;
      }

      if (active.classList.contains('horse-card')) {
        event.preventDefault();
        setPreviewHorse(active.dataset.horseId);
      }
    }
  }

  if (event.key === 'Escape') {
    closeModal();
  }
}

function handleAction(action, target) {
  if (!action) return;
  switch (action) {
    case 'toPredict':
      switchScreen('predict');
      break;
    case 'openHowTo':
      openModal(howtoModal);
      break;
    case 'closeModal':
      closeModal();
      break;
    case 'selectHorse':
      confirmPreviewSelection();
      break;
    case 'backToTitle':
      clearSelections();
      switchScreen('title');
      break;
    case 'clearSelection':
      clearSelections();
      break;
    case 'startRace':
      startRace();
      break;
    case 'speedUp':
      raceController?.triggerSpeedUp();
      break;
    case 'replay':
      clearSelections();
      switchScreen('title');
      break;
    default:
      break;
  }
}

// ---------------------------------------------
// モーダルの開閉
// ---------------------------------------------
function openModal(modal) {
  if (!modal) return;
  modal.classList.remove('is-hidden');
  backdrop.classList.remove('is-hidden');
}

function closeModal() {
  document.querySelectorAll('.modal').forEach((modal) => modal.classList.add('is-hidden'));
  backdrop.classList.add('is-hidden');
}

// ---------------------------------------------
// 選択関連の処理
// ---------------------------------------------
function setPreviewHorse(horseId) {
  if (!horseId) {
    resetPreviewPanel();
    return;
  }

  if (currentPreviewCard) {
    currentPreviewCard.classList.remove('is-preview');
    currentPreviewCard = null;
  }

  const card = document.querySelector(`.horse-card[data-horse-id="${horseId}"]`);
  if (card) {
    card.classList.add('is-preview');
    currentPreviewCard = card;
  }

  previewHorseId = horseId;
  const horse = horses.find((h) => h.id === horseId);
  if (!horse) {
    resetPreviewPanel();
    return;
  }

  if (previewNameImg) {
    if (horse.nameImg) {
      previewNameImg.src = horse.nameImg;
      previewNameImg.alt = `${horse.name}の紹介画像`;
      previewNameImg.hidden = false;
    } else {
      previewNameImg.hidden = true;
    }
  }
  updateSelectButton();
}

function resetPreviewPanel() {
  previewHorseId = null;
  if (currentPreviewCard) {
    currentPreviewCard.classList.remove('is-preview');
    currentPreviewCard = null;
  }
  if (previewNameImg) {
    previewNameImg.src = '';
    previewNameImg.hidden = true;
  }
  updateSelectButton();
}

function confirmPreviewSelection() {
  if (!previewHorseId) return;
  if (selectedOrder.includes(previewHorseId)) return;

  const emptyIndex = selectedOrder.findIndex((id) => !id);
  if (emptyIndex === -1) return;

  selectedOrder[emptyIndex] = previewHorseId;
  updateSelectionSlots();
  updateCardsBadge();
  updateStartButton();
  updateSelectButton();
}

function removeSelectionAt(rank) {
  if (rank < 0 || rank >= selectedOrder.length) return;
  const removed = selectedOrder[rank];
  if (!removed) return;

  selectedOrder[rank] = null;
  updateSelectionSlots();
  updateCardsBadge();
  updateStartButton();
  setPreviewHorse(removed);
  updateSelectButton();
}

function clearSelections() {
  selectedOrder = Array(MAX_SELECTION_RANKS).fill(null);
  updateSelectionSlots();
  updateCardsBadge();
  updateStartButton();
  resetPreviewPanel();
}

function updateSelectionSlots() {
  selectionSlots.forEach((slot, index) => {
    const img = slotImages[index];
    const clearBtn = slotClearButtons[index];
    const horseId = selectedOrder[index];
    if (horseId) {
      const horse = horses.find((h) => h.id === horseId);
      if (img && horse) {
        img.src = horse.img;
        img.alt = `${horse.name}のイラスト`;
      }
      if (clearBtn) {
        clearBtn.hidden = false;
        clearBtn.dataset.removeRank = String(index);
      }
    } else {
      if (img) {
        img.src = placeholderHorseSrc;
        img.alt = '未選択のシルエット';
      }
      if (clearBtn) {
        clearBtn.hidden = true;
        clearBtn.removeAttribute('data-remove-rank');
      }
    }
  });
}

function updateStartButton() {
  startButton.disabled = !selectedOrder.every((id) => Boolean(id));
}

function updateSelectButton() {
  if (!selectButton) return;
  const filledCount = selectedOrder.reduce((count, id) => (id ? count + 1 : count), 0);
  const shouldDisable =
    !previewHorseId || filledCount >= MAX_SELECTION_RANKS || selectedOrder.includes(previewHorseId);
  selectButton.disabled = shouldDisable;
}

function updateCardsBadge() {
  const cardElements = document.querySelectorAll('.horse-card');
  cardElements.forEach((card) => {
    const id = card.dataset.horseId;
    card.querySelector('.badge')?.remove();
    const index = selectedOrder.indexOf(id);
    if (index !== -1) {
      const badge = document.createElement('span');
      badge.className = 'badge';
      badge.textContent = index + 1;
      card.append(badge);
    }
  });
}

// ---------------------------------------------
// 画面遷移（フェード用クラス操作）
// ---------------------------------------------
function switchScreen(screenId) {
  if (currentScreen === screenId) return;
  const previous = document.querySelector(`.screen[data-screen-id="${currentScreen}"]`);
  const next = document.querySelector(`.screen[data-screen-id="${screenId}"]`);
  if (!next) return;

  previous?.classList.remove('is-active');
  previous?.classList.add('is-leaving');
  next.classList.add('is-active');
  next.classList.remove('is-leaving');
  app.dataset.screen = screenId;
  updateControls(screenId);
  currentScreen = screenId;

  if (previous) {
    setTimeout(() => {
      previous.classList.remove('is-leaving');
      previous.setAttribute('aria-hidden', 'true');
    }, 180);
  }
  next.setAttribute('aria-hidden', 'false');
}

function updateControls(screenId) {
  controlGroups.forEach((group) => {
    if (group.dataset.controlsId === screenId) {
      group.classList.add('is-active');
      group.removeAttribute('aria-hidden');
    } else {
      group.classList.remove('is-active');
      group.setAttribute('aria-hidden', 'true');
    }
  });
  requestAnimationFrame(() => {
    updateStageSize();
  });
}

// ---------------------------------------------
// レース開始処理
// ---------------------------------------------
function startRace() {
  if (!selectedOrder.every((id) => Boolean(id))) {
    console.warn('[race] 3頭選択後にレースを開始してください。');
    return;
  }
  switchScreen('race');
  speedButton.disabled = false;
  speedButton.textContent = 'SPEED UP';
  populateRacePredictionPanel();
  resetTekichuBadges();
  resetRaceFinishElements();
  const resolvedSelection = selectedOrder.map((id) => {
    const horse = horses.find((h) => h.id === id);
    if (!horse) {
      console.warn('[race] 選択したIDに対応する馬データが見つかりませんでした。', {
        horseId: id
      });
    }
    return horse || null;
  });
  raceController = new RaceController(resolvedSelection);
  raceController.start();
}

function populateRacePredictionPanel() {
  if (!racePredictionList) return;
  racePredictionList.innerHTML = '';
  racePredictionHorseImgs.length = 0;
  racePredictionTekichuImgs.length = 0;
  const order = [0, 1, 2];
  order.forEach((index) => {
    const horseId = selectedOrder[index];
    const horse = horses.find((h) => h.id === horseId);
    const item = document.createElement('li');
    item.className = 'race-prediction-item';
    item.dataset.rank = String(index + 1);
    if (horse) {
      const img = document.createElement('img');
      img.className = 'race-prediction-horse';
      img.src = horse.img;
      img.alt = '';
      img.setAttribute('aria-hidden', 'true');
      item.append(img);
      racePredictionHorseImgs[index] = img;
      const sr = document.createElement('span');
      sr.className = 'sr-only';
      sr.textContent = `${index + 1}着 ${horse.name}`;
      item.append(sr);
    } else {
      const img = document.createElement('img');
      img.className = 'race-prediction-horse';
      img.src = placeholderHorseSrc;
      img.alt = '';
      img.setAttribute('aria-hidden', 'true');
      item.append(img);
      racePredictionHorseImgs[index] = img;
      const sr = document.createElement('span');
      sr.className = 'sr-only';
      sr.textContent = `${index + 1}着 未選択`;
      item.append(sr);
    }
    const badge = document.createElement('img');
    badge.className = 'race-tekichu';
    badge.src = RACE_TEKICHU_SRC;
    badge.alt = '的中';
    badge.setAttribute('aria-hidden', 'true');
    item.append(badge);
    racePredictionTekichuImgs[index] = badge;
    racePredictionList.append(item);
  });
}

function resetTekichuBadges() {
  racePredictionTekichuImgs.forEach((badge) => {
    if (badge) {
      badge.classList.remove('is-visible');
    }
  });
}

function markTekichuBadge(rankIndex) {
  const badge = racePredictionTekichuImgs[rankIndex];
  if (badge) {
    badge.classList.add('is-visible');
  }
}

function resetRaceFinishElements() {
  if (raceController) {
    raceController.dispose();
    raceController = null;
  }
  if (countdownEl) {
    countdownEl.textContent = '';
  }
  if (speedButton) {
    speedButton.disabled = true;
    speedButton.textContent = 'SPEED UP';
  }
  if (raceCanvas) {
    const ctx = raceCanvas.getContext('2d');
    if (ctx) {
      ctx.clearRect(0, 0, raceCanvas.width, raceCanvas.height);
    }
  }
  resetTekichuBadges();
}

// ---------------------------------------------
// レース制御クラス
// ---------------------------------------------

class RaceController {
  constructor(selectedHorses) {
    const sanitized = Array.isArray(selectedHorses)
      ? selectedHorses.map((horse) => horse || null)
      : [];
    this.selectedHorses = sanitized;
    this.heroHorse = sanitized[0] || createPlaceholderHorse('hero');
    this.secondHorse = sanitized[1] || null;
    this.thirdHorse = sanitized[2] || null;
    this.canvas = raceCanvas;
    this.ctx = this.canvas ? this.canvas.getContext('2d') : null;
    this.running = false;
    this.speedMultiplier = 1;
    this.speedBoostRemaining = 0;
    this.baseSpeed = 0;
    this.currentSpeed = 0;
    this.lastTimestamp = 0;
    this.stateIndex = 0;
    this.stateElapsedMs = 0;
    this.sequence = [...RACE_STATE_SEQUENCE];
    this.backgroundOffsets = { sky: 0, bloom: 0, ground: 0 };
    this.goal = null;
    this.goalCenterX = 0;
    this.heroRunner = null;
    this.secondRunner = null;
    this.thirdRunner = null;
    this.otherRunners = [];
    this.runnerHeight = 0;
    this.stageScale = 1;
    this.stageWidth = 0;
    this.stageHeight = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.passMargin = 0;
    this.finishSpeed = 0;
    this.rafId = null;
    this.countdownValues = ['3', '2', '1', 'GO!'];
    this.completing = false;
    this.timelineSeconds = 0;
    this.relativeAdvanceSpeed = 0;
    this.distanceMarkerOffset = 0;
    this.markerSpacing = 0;
    this.markerHeight = 0;
    this.markerWidth = 0;
    this.afterStraight = false;
    this.straightTelopTimer = 0;
    this.zoomTimer = 0;
    this.photoFinishTimer = 0;
    this.photoFlashTimer = 0;
    this.photoFinishActive = false;
    this.stageEl = raceStageEl;
    this.trackEl = raceTrack;
    this.straightTelopEl = raceStraightTelopEl;
    this.photoFlashEl = racePhotoFlashEl;
    this.distanceTelopEls = raceDistanceTelops;
    this.distanceTelopState = {
      200: { remaining: 0 },
      100: { remaining: 0 }
    };
    this.distanceTelopQueue = [];
    this.zoomScale = 1;
    this.panX = 0;
    this.panY = 0;
    this.shakeConfig = null;
    this.shakeTimer = 0;
    this.shakeTotal = 0;
    this.climaxActive = false;
    this.climaxTimer = 0;
    this.climaxDurationMs = 0;
    this.climaxContenders = [];
    this.climaxContenderData = new Map();
    this.climaxShakeTriggered = false;
    this.climaxReliefTimer = 0;
    this.climaxReliefDuration = 0;
    this.climaxExtraZoom = 0;
    this.dustParticles = [];
    this.dustAccumulator = 0;
    this.dustRateMultiplier = 1;
    this.heroCameraBias = 0;
  }

  dispose() {
    if (this.rafId !== null) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
    this.running = false;
    this.speedMultiplier = 1;
    this.speedBoostRemaining = 0;
    this.toggleClimaxVisuals(false);
    this.setTrackZoom(1);
    this.setTrackPan(0, 0);
    this.setTrackShake(0, 0);
    this.clearClimaxContenders();
  }

  async start() {
    if (!this.canvas || !this.ctx) {
      console.warn('[race] キャンバス要素が見つからないため、レース演出を開始できません。');
      return;
    }

    await this.ensureAssets();
    this.setupScene();
    this.render(); // カウントダウン前に初期状態を描画
    await this.prepareCountdown();

    this.running = true;
    this.lastTimestamp = performance.now();
    this.refreshSpeedControl();
    window.race = this;
    this.rafId = requestAnimationFrame(this.update.bind(this));
  }

  async ensureAssets() {
    if (raceAssetPromise) {
      return raceAssetPromise;
    }

    const sources = new Set([
      RACE_ASSET_PATHS.sky,
      RACE_ASSET_PATHS.bloom,
      RACE_ASSET_PATHS.ground,
      RACE_ASSET_PATHS.goal,
      RACE_TEKICHU_SRC,
      placeholderHorseSrc
    ]);

    this.selectedHorses.forEach((horse) => {
      if (horse?.img) {
        sources.add(horse.img);
      }
    });
    horses.forEach((horse) => {
      if (horse?.img) {
        sources.add(horse.img);
      }
    });

    raceAssetPromise = Promise.all(
      Array.from(sources).map((src) => loadImage(src))
    ).then((entries) => {
      entries.forEach(([src, image]) => {
        if (image) {
          raceAssetCache.set(src, image);
        }
      });
      return raceAssetCache;
    });

    return raceAssetPromise;
  }

  async prepareCountdown() {
    return new Promise((resolve) => {
      let index = 0;
      if (countdownEl) {
        countdownEl.textContent = this.countdownValues[index];
      }
      const timer = setInterval(() => {
        index += 1;
        if (index >= this.countdownValues.length) {
          clearInterval(timer);
          if (countdownEl) {
            countdownEl.textContent = '';
          }
          resolve();
        } else if (countdownEl) {
          countdownEl.textContent = this.countdownValues[index];
        }
      }, COUNTDOWN_INTERVAL_MS);
    });
  }

  setupScene() {
    this.stageWidth = this.canvas.width;
    this.stageHeight = this.canvas.height;
    this.scaleX = this.stageWidth / RACE_VIRTUAL_WIDTH;
    this.scaleY = this.stageHeight / RACE_VIRTUAL_HEIGHT;
    this.stageScale = this.stageHeight / RACE_STAGE_BASE_HEIGHT;
    this.heroCameraBias = this.stageWidth * RACE_CAMERA_HERO_BIAS;
    const stageX = (value) => (value / STAGE_RATIO_W) * this.stageWidth;
    const stageY = (value) => (value / RACE_STAGE_BASE_HEIGHT) * this.stageHeight;
    this.runnerHeight = stageY(130);
    this.passMargin = stageX(RACE_PASS_MARGIN);
    this.finishSpeed = this.toCanvasSpeed(RACE_FINISH_SPEED);
    this.baseSpeed = this.toCanvasSpeed(RACE_BASE_SPEED_PER_SEC);
    this.currentSpeed = this.baseSpeed;
    this.backgroundOffsets = { sky: 0, bloom: 0, ground: 0 };
    this.completing = false;
    this.relativeAdvanceSpeed = this.toCanvasSpeed(RACE_MIN_RELATIVE_SPEED_PER_SEC);
    this.timelineSeconds = 0;
    this.markerSpacing = this.stageToCanvasX(RACE_DISTANCE_MARKER_SPACING);
    this.markerHeight = stageY(RACE_DISTANCE_MARKER_HEIGHT);
    this.markerWidth = Math.max(2, this.stageToCanvasX(RACE_DISTANCE_MARKER_WIDTH));
    this.distanceMarkerOffset = 0;
    this.afterStraight = false;
    this.straightTelopTimer = 0;
    this.zoomTimer = 0;
    this.photoFinishTimer = 0;
    this.photoFlashTimer = 0;
    this.photoFinishActive = false;
    this.updateZoomClass(false);
    this.toggleStraightTelop(false);
    this.updatePhotoFlash(0);
    this.toggleClimaxVisuals(false);
    this.climaxActive = false;
    this.climaxTimer = 0;
    this.climaxDurationMs = 0;
    this.climaxShakeTriggered = false;
    this.climaxReliefTimer = 0;
    this.climaxReliefDuration = 0;
    this.climaxExtraZoom = 0;
    this.climaxContenders = [];
    this.climaxContenderData.clear();
    this.setTrackPan(0, 0);
    this.setTrackShake(0, 0);
    if (this.stageEl) {
      this.stageEl.style.setProperty('--race-ground-blur', '0px');
    }
    this.setTrackZoom(1);
    this.dustParticles = [];
    this.dustAccumulator = 0;
    this.dustRateMultiplier = 1;
    this.distanceTelopQueue = [];
    Object.values(this.distanceTelopState).forEach((entry) => {
      entry.remaining = 0;
    });
    this.showDistanceTelop('200', false);
    this.showDistanceTelop('100', false);

    this.heroRunner = this.createRunner(this.heroHorse, {
      x: stageX(90),
      y: stageY(396),
      fixed: true,
      label: 'hero',
      rankIndex: 0,
      waveAmplitude: 0,
      boostSensitivity: 0,
      legType: 'front'
    });

    const heroCenter = this.heroRunner.x + this.heroRunner.width / 2;
    const heroFront = this.heroRunner.x + this.heroRunner.width;
    const secondHoldOffset = stageX(RACE_SECOND_HOLD_OFFSET);
    const thirdHoldOffset = stageX(RACE_THIRD_HOLD_OFFSET);

    this.secondRunner = this.secondHorse
      ? this.createRunner(this.secondHorse, {
          x: heroFront,
          y: stageY(520),
          speedFactor: 1.08,
          label: 'second',
          rankIndex: 1,
          holdOffset: secondHoldOffset,
          waveAmplitude: RACE_SURGE_AMPLITUDE * 1.1,
          boostSensitivity: 0.75,
          legType: 'stalker'
        })
      : null;
    if (this.secondRunner) {
      const center = heroCenter + secondHoldOffset;
      this.secondRunner.x = center - this.secondRunner.width / 2;
    }

    this.thirdRunner = this.thirdHorse
      ? this.createRunner(this.thirdHorse, {
          x: heroFront,
          y: stageY(600),
          speedFactor: 1.04,
          label: 'third',
          rankIndex: 2,
          holdOffset: thirdHoldOffset,
          waveAmplitude: RACE_SURGE_AMPLITUDE * 1.05,
          boostSensitivity: 0.8,
          legType: 'closer'
        })
      : null;
    if (this.thirdRunner) {
      const center = heroCenter + thirdHoldOffset;
      this.thirdRunner.x = center - this.thirdRunner.width / 2;
    }

    const selectedIds = this.selectedHorses
      .filter(Boolean)
      .map((horse) => horse.id);
    const laneHeights = RACE_OTHER_LANES.map((lane) => stageY(lane));
    const laneCount = Math.max(1, laneHeights.length);
    const othersSource = shuffleArray(
      horses.filter((horse) => !selectedIds.includes(horse.id))
    );

    this.otherRunners = othersSource.map((horse, index) => {
      const laneIndex = index % laneCount;
      const rowIndex = Math.floor(index / laneCount);
      const waveScale = 0.7 + Math.random() * 0.6;
      const legType = RACE_LEG_TYPES[index % RACE_LEG_TYPES.length];
      const runner = this.createRunner(horse, {
        x: heroFront,
        y: laneHeights[laneIndex],
        speedFactor: 1.08 + Math.random() * 0.08,
        label: `other-${index + 1}`,
        allowedToPass: false,
        laneIndex,
        rowIndex,
        slotIndex: index,
        waveAmplitude: RACE_SURGE_AMPLITUDE * waveScale,
        boostSensitivity: 1,
        legType
      });
      return runner;
    });

    this.resetOthersToPack();
    this.prepareOthersForRun(true);

    this.goal = this.createGoal();
    this.goalCenterX = this.goal ? this.goal.targetX : this.stageWidth * RACE_GOAL_TARGET_RATIO;
    this.stateIndex = 0;
    this.stateElapsedMs = 0;
    if (this.sequence.length > 0) {
      this.applyStateEntry(this.sequence[0]);
    }
  }

  updateZoomClass(enable) {
    if (!this.stageEl) return;
    if (enable) {
      this.stageEl.classList.add('is-straight-zoom');
      this.setTrackZoom(RACE_STRAIGHT_ZOOM_SCALE);
    } else {
      this.stageEl.classList.remove('is-straight-zoom');
      this.setTrackZoom(1);
    }
  }

  toggleStraightTelop(show) {
    if (!this.straightTelopEl) return;
    if (show) {
      this.straightTelopEl.textContent = RACE_STRAIGHT_TELOP_TEXT;
      this.straightTelopEl.classList.add('is-visible');
    } else {
      this.straightTelopEl.classList.remove('is-visible');
    }
  }

  enterClimaxState(duration) {
    this.climaxActive = true;
    this.climaxDurationMs = duration ?? scaledDuration(RACE_CLIMAX_DURATION);
    this.climaxTimer = 0;
    this.climaxShakeTriggered = false;
    this.climaxReliefTimer = 0;
    this.climaxReliefDuration = 0;
    this.applyImmersionProfile('climax');
    const baseZoom = 1 + (RACE_STATE_IMMERSION.climax?.zoom ?? 0);
    const targetZoom = Math.max(
      baseZoom + RACE_CLIMAX_EXTRA_ZOOM,
      RACE_CLIMAX_ZOOM_TO
    );
    this.climaxExtraZoom = targetZoom;
    this.setTrackZoom(targetZoom);
    this.toggleClimaxVisuals(true);
    this.applyClimaxLaneOffsets();
    this.setupClimaxContenders();
    this.distanceTelopQueue = [
      { distance: '200', delay: RACE_CLIMAX_DISTANCE_TOGGLE_200 },
      { distance: '100', delay: RACE_CLIMAX_DISTANCE_TOGGLE_100 }
    ];
    Object.values(this.distanceTelopState).forEach((entry) => {
      entry.remaining = 0;
    });
    this.showDistanceTelop('200', false);
    this.showDistanceTelop('100', false);
  }

  endClimaxState() {
    this.climaxActive = false;
    this.dustRateMultiplier = 1;
    this.toggleClimaxVisuals(false);
    if (this.afterStraight) {
      this.setTrackZoom(RACE_STRAIGHT_ZOOM_SCALE);
    } else {
      this.setTrackZoom(1);
    }
    [this.heroRunner, this.secondRunner, this.thirdRunner]
      .filter(Boolean)
      .forEach((runner) => {
        runner.visualOffsetX = 0;
        runner.visualOffsetY = 0;
        if (runner.baseY != null) {
          runner.y = runner.baseY;
        }
      });
    if (this.otherRunners) {
      this.otherRunners.forEach((runner) => {
        runner.visualOffsetX = 0;
        runner.visualOffsetY = 0;
        if (runner.baseY != null) {
          runner.y = runner.baseY;
        }
      });
    }
    this.setTrackPan(0, 0);
    this.setTrackShake(0, 0);
    this.clearClimaxContenders();
    this.climaxReliefTimer = 0;
    this.climaxReliefDuration = 0;
    this.showDistanceTelop('200', false);
    this.showDistanceTelop('100', false);
  }

  applyClimaxLaneOffsets() {
    if (this.heroRunner && this.heroRunner.baseY != null) {
      const shift = this.stageToCanvasY(RACE_CLIMAX_HERO_INNER_SHIFT);
      this.heroRunner.y = this.heroRunner.baseY - shift;
    }
    const rivals = [this.secondRunner, this.thirdRunner].filter(Boolean);
    rivals.forEach((runner) => {
      const [minShift, maxShift] = RACE_CLIMAX_RIVAL_OUTER_SHIFT;
      const shift = this.stageToCanvasY(randomRange(minShift, maxShift));
      if (runner.baseY != null) {
        runner.y = runner.baseY + shift;
      }
    });
  }

  setupClimaxContenders() {
    this.climaxContenderData.clear();
    this.climaxContenders = [];
    if (!Array.isArray(this.otherRunners) || !this.otherRunners.length) {
      return;
    }
    const active = this.otherRunners.filter((runner) => runner && runner.spawned && !runner.exited);
    if (!active.length) {
      return;
    }
    const candidates = shuffleArray(active);
    const extrasNeeded = Math.max(0, RACE_CLIMAX_CONTENDER_TOTAL - 3);
    const desiredExtras = Math.max(0, extrasNeeded, RACE_CLIMAX_EXTRA_CONTENDERS);
    const count = Math.min(desiredExtras, candidates.length);
    const baseStick = this.stageToCanvasX(RACE_CLIMAX_CONTENDER_STICK_PX);
    const releaseAt = Math.max(0, this.climaxDurationMs - 400);
    for (let i = 0; i < count; i += 1) {
      const runner = candidates[i];
      if (!runner) continue;
      const leadDuration = randomRange(
        RACE_CLIMAX_FAKE_LEAD_TIME[0],
        RACE_CLIMAX_FAKE_LEAD_TIME[1]
      );
      const maxStart = Math.max(0, releaseAt - leadDuration - 60);
      const windowMin = RACE_CLIMAX_CONTENDER_FAKE_LEAD[0];
      const windowMax = Math.max(windowMin, Math.min(RACE_CLIMAX_CONTENDER_FAKE_LEAD[1], maxStart));
      const leadStart = Math.min(maxStart, randomRange(windowMin, windowMax));
      const ratio = count > 1 ? i / Math.max(1, count - 1) : 0;
      const stickMultiplier = 0.82 + ratio * 0.28;
      this.climaxContenderData.set(runner, {
        runner,
        baseOffset: baseStick * stickMultiplier,
        leadStart,
        leadDuration,
        leadElapsed: 0,
        leading: false,
        triggered: false,
        releaseAt,
        released: false
      });
      runner.allowedToPass = true;
      runner.passed = false;
      runner.opacity = 1;
      runner.fading = false;
      runner.fadeElapsed = 0;
      runner.fadeDuration = 0;
      runner.visualOffsetX = 0;
      this.climaxContenders.push(runner);
    }
  }

  updateClimaxContenders(deltaSeconds, heroCenter) {
    if (!this.climaxContenderData.size) {
      return;
    }
    const deltaMs = deltaSeconds * 1000;
    const removals = [];
    this.climaxContenderData.forEach((info, runner) => {
      if (!runner || runner.exited) {
        removals.push(runner);
        return;
      }
      if (!info.released && this.climaxTimer >= info.releaseAt) {
        info.released = true;
        runner.visualOffsetX = 0;
        removals.push(runner);
        return;
      }
      if (info.released) {
        return;
      }
      if (!info.triggered && this.climaxTimer >= info.leadStart) {
        info.leading = true;
        info.triggered = true;
        info.leadElapsed = 0;
      }
      if (info.leading) {
        info.leadElapsed += deltaMs;
        if (info.leadElapsed >= info.leadDuration) {
          info.leading = false;
        }
      }
      const currentCenter = runner.x + runner.width / 2;
      let targetCenter = heroCenter + (info.baseOffset ?? 0);
      if (info.leading) {
        const half = Math.max(info.leadDuration / 2, 1);
        const normalized = Math.max(0, 1 - Math.abs(info.leadElapsed - half) / half);
        const leadShift = this.stageToCanvasX(RACE_CLIMAX_FAKE_LEAD_PX) * normalized;
        targetCenter = heroCenter - leadShift;
      }
      const followRate = RACE_OTHER_PACK_FOLLOW_RATE * 2.4;
      const rate = Math.min(1, deltaSeconds * followRate);
      runner.x += (targetCenter - currentCenter) * rate;
      runner.passed = false;
      runner.opacity = 1;
      runner.fading = false;
    });
    if (removals.length) {
      removals.forEach((runner) => {
        this.climaxContenderData.delete(runner);
        const index = this.climaxContenders.indexOf(runner);
        if (index >= 0) {
          this.climaxContenders.splice(index, 1);
        }
      });
    }
  }

  clearClimaxContenders() {
    if (this.climaxContenderData.size) {
      this.climaxContenderData.forEach((info) => {
        if (info?.runner) {
          info.runner.visualOffsetX = 0;
          info.runner.fading = false;
          info.runner.opacity = 1;
        }
      });
    }
    this.climaxContenderData.clear();
    this.climaxContenders = [];
  }

  isClimaxContender(runner) {
    return Boolean(runner && this.climaxContenderData.has(runner));
  }

  activateClimaxBoost() {
    const total = SPEED_UP_DURATION_MS + RACE_CLIMAX_RELIEF_FADEOUT;
    this.climaxReliefDuration = total;
    this.climaxReliefTimer = total;
  }

  queueDistanceTelops(deltaMs) {
    if (!this.distanceTelopQueue.length) return;
    const remaining = [];
    this.distanceTelopQueue.forEach((item) => {
      if (!this.distanceTelopState[item.distance]) {
        return;
      }
      const nextDelay = (item.delay ?? 0) - deltaMs;
      if (nextDelay <= 0) {
        this.distanceTelopState[item.distance].remaining = RACE_CLIMAX_DISTANCE_DURATION;
        this.showDistanceTelop(item.distance, true);
      } else {
        remaining.push({ distance: item.distance, delay: nextDelay });
      }
    });
    this.distanceTelopQueue = remaining;
  }

  updateDistanceTelops(deltaMs) {
    Object.entries(this.distanceTelopState).forEach(([key, entry]) => {
      if (entry.remaining <= 0) return;
      entry.remaining = Math.max(0, entry.remaining - deltaMs);
      if (entry.remaining === 0) {
        this.showDistanceTelop(key, false);
      }
    });
  }

  startShake(config) {
    if (!config) return;
    this.shakeConfig = {
      amplitude: config.amplitude,
      duration: (config.duration ?? 0) / 1000,
      repeats: config.repeats ?? 1
    };
    this.shakeTimer = 0;
    this.shakeTotal = 0;
  }

  updatePhotoFlash(alpha) {
    if (!this.photoFlashEl) return;
    const clamped = Math.max(0, Math.min(1, alpha || 0));
    this.photoFlashEl.style.opacity = clamped.toFixed(3);
  }

  setTrackZoom(scale) {
    this.zoomScale = scale;
    if (this.trackEl) {
      this.trackEl.style.setProperty('--race-zoom-scale', scale.toFixed(4));
    }
  }

  setTrackPan(x, y) {
    this.panX = x;
    this.panY = y;
    if (this.trackEl) {
      this.trackEl.style.setProperty('--race-pan-x', `${x.toFixed(2)}px`);
      this.trackEl.style.setProperty('--race-pan-y', `${y.toFixed(2)}px`);
    }
  }

  setTrackShake(x = 0, y = 0) {
    if (this.trackEl) {
      this.trackEl.style.setProperty('--race-shake-x', `${x.toFixed(2)}px`);
      this.trackEl.style.setProperty('--race-shake-y', `${y.toFixed(2)}px`);
    }
  }

  toggleClimaxVisuals(enable) {
    if (!this.stageEl) return;
    this.stageEl.classList.toggle('is-climax', Boolean(enable));
  }

  showDistanceTelop(distanceKey, show) {
    const el = this.distanceTelopEls?.[distanceKey];
    if (!el) return;
    el.classList.toggle('is-visible', Boolean(show));
  }

  triggerStraightPhase() {
    this.afterStraight = true;
    this.straightTelopTimer = RACE_STRAIGHT_TELOP_DURATION_MS;
    this.zoomTimer = RACE_STRAIGHT_ZOOM_DURATION_MS;
    this.toggleStraightTelop(true);
    this.updateZoomClass(true);
  }

  updateEffects(deltaSeconds) {
    if (this.straightTelopTimer > 0) {
      this.straightTelopTimer = Math.max(
        0,
        this.straightTelopTimer - deltaSeconds * 1000
      );
      if (this.straightTelopTimer === 0) {
        this.toggleStraightTelop(false);
      }
    }
    if (this.zoomTimer > 0) {
      this.zoomTimer = Math.max(0, this.zoomTimer - deltaSeconds * 1000);
      if (this.zoomTimer === 0) {
        this.updateZoomClass(false);
      }
    }
    if (this.photoFinishTimer > 0) {
      this.photoFinishTimer = Math.max(0, this.photoFinishTimer - deltaSeconds * 1000);
      if (this.photoFinishTimer === 0) {
        this.photoFinishActive = false;
      }
    }
    if (this.photoFlashTimer > 0) {
      this.photoFlashTimer = Math.max(0, this.photoFlashTimer - deltaSeconds * 1000);
    }
    const flashAlpha =
      this.photoFlashTimer > 0
        ? (this.photoFlashTimer / RACE_PHOTO_FLASH_DURATION_MS) * RACE_PHOTO_FLASH_MAX_ALPHA
        : 0;
    this.updatePhotoFlash(flashAlpha);
  }

  triggerPhotoFinish() {
    if (this.photoFinishActive) {
      return;
    }
    this.photoFinishActive = true;
    this.photoFinishTimer = RACE_PHOTO_LINE_DURATION_MS;
    this.photoFlashTimer = RACE_PHOTO_FLASH_DURATION_MS;
    this.updatePhotoFlash(RACE_PHOTO_FLASH_MAX_ALPHA);
  }

  createGoal() {
    const image = this.resolveImage(RACE_ASSET_PATHS.goal);
    const height = (223 / RACE_STAGE_BASE_HEIGHT) * this.stageHeight;
    const aspect = image && image.height ? image.width / image.height : 1;
    const width = height * aspect;
    const startX = this.stageWidth + width;
    const top = (170 / RACE_STAGE_BASE_HEIGHT) * this.stageHeight;
    return {
      image,
      startX,
      x: startX,
      targetX: this.stageWidth * RACE_GOAL_TARGET_RATIO,
      y: top,
      width,
      height,
      progress: 0,
      active: false,
      stopped: false
    };
  }

  applyStateEntry(state) {
    this.stateElapsedMs = 0;
    const factor = RACE_STATE_SPEED_FACTORS[state.key];
    if (typeof factor === 'number') {
      this.currentSpeed = this.baseSpeed * factor;
    }
    if (state.key !== 'climax' && this.climaxActive) {
      this.endClimaxState();
    }
    switch (state.key) {
      case 'intro':
        break;
      case 'others':
        this.prepareOthersForRun(true);
        this.alignFinalistToHold(this.secondRunner);
        this.alignFinalistToHold(this.thirdRunner);
        break;
      case RACE_STRAIGHT_STATE_KEY:
        this.alignFinalistToHold(this.secondRunner);
        this.alignFinalistToHold(this.thirdRunner);
        this.triggerStraightPhase();
        break;
      case 'climax':
        this.enterClimaxState(state.duration);
        break;
      case 'third':
        if (this.thirdRunner) {
          this.alignFinalistToHold(this.thirdRunner);
          this.thirdRunner.speedFactor = Math.min(1.16, this.thirdRunner.speedFactor + 0.12);
          this.thirdRunner.boosted = true;
        }
        break;
      case 'second':
        if (this.secondRunner) {
          this.alignFinalistToHold(this.secondRunner);
          this.secondRunner.speedFactor = Math.min(1.18, this.secondRunner.speedFactor + 0.12);
          this.secondRunner.boosted = true;
        }
        break;
      case 'lead':
        if (this.secondRunner) {
          this.secondRunner.speedFactor = Math.max(1.05, this.secondRunner.baseFactor ?? 1.05);
          this.secondRunner.boosted = false;
        }
        if (this.thirdRunner) {
          this.thirdRunner.speedFactor = Math.max(1.02, this.thirdRunner.baseFactor ?? 1.02);
          this.thirdRunner.boosted = false;
        }
        break;
      case 'goal':
        if (this.goal) {
          this.goal.active = true;
          this.goal.stopped = false;
          this.goal.progress = 0;
          this.goal.x = this.goal.startX;
        }
        break;
      case 'finish':
        this.prepareFinishRunners();
        break;
      default:
        break;
    }
    if (state.key !== 'climax') {
      this.applyImmersionProfile(state.key);
    }
    this.refreshSpeedControl();
  }

  applyImmersionProfile(stateKey) {
    const profile =
      RACE_STATE_IMMERSION[stateKey] ?? RACE_STATE_IMMERSION.default ?? null;
    const zoomDelta = profile?.zoom ?? 0;
    const panXStage = profile?.panX ?? 0;
    const panYStage = profile?.panY ?? 0;
    const blur = profile?.groundBlur ?? 0;
    const dust = profile?.dust ?? 1;
    const shake = profile?.shake ?? 0;

    const zoomTarget = 1 + zoomDelta;
    this.setTrackZoom(zoomTarget);

    const panX = this.stageToCanvasX(panXStage) + (this.heroCameraBias || 0);
    const panY = this.stageToCanvasY(panYStage);
    this.setTrackPan(panX, panY);

    if (this.stageEl) {
      this.stageEl.style.setProperty('--race-ground-blur', `${blur}px`);
    }

    this.dustRateMultiplier = dust;

    if (shake > 0) {
      this.startShake({ amplitude: shake, duration: 120, repeats: 1 });
    } else if (!this.climaxActive) {
      this.setTrackShake(0, 0);
    }
  }

  resetOthersToPack() {
    if (!this.otherRunners || !this.heroRunner) return;
    const heroCenter = this.heroRunner.x + this.heroRunner.width / 2;
    const baseOffset = this.stageToCanvasX(RACE_OTHER_PACK_BASE_OFFSET);
    const columnSpacing = this.stageToCanvasX(RACE_OTHER_PACK_COLUMN_SPACING);
    const rowSpacing = this.stageToCanvasX(RACE_OTHER_PACK_ROW_SPACING);
    const laneCount = Math.max(1, RACE_OTHER_LANES.length);

    this.otherRunners.forEach((runner, index) => {
      const laneIndex = runner.laneIndex ?? (index % laneCount);
      const rowIndex = runner.rowIndex ?? Math.floor(index / laneCount);
      const alignOffset = baseOffset + columnSpacing * laneIndex + rowSpacing * rowIndex;
      runner.packAlignOffset = alignOffset;
      const desiredCenter = heroCenter + alignOffset;
      runner.x = desiredCenter - runner.width / 2;
      runner.passDelayBase =
        RACE_OTHER_PASS_DELAY_BASE_MS +
        rowIndex * RACE_OTHER_PASS_DELAY_STEP_MS +
        laneIndex * RACE_OTHER_PASS_DELAY_COLUMN_MS;
      runner.passDelayJitter = Math.random() * RACE_OTHER_PASS_DELAY_RANDOM_MS;
      runner.passDelay = runner.passDelayBase + runner.passDelayJitter;
      runner.opacity = 1;
      runner.fading = false;
      runner.fadeElapsed = 0;
      runner.fadeDuration = 0;
    });
  }

  prepareOthersForRun(resetTimer = true) {
    if (!this.otherRunners) return;
    this.otherRunners.forEach((runner) => {
      runner.active = true;
      runner.spawned = true;
      runner.passed = false;
      runner.exited = false;
      runner.allowedToPass = false;
      runner.speedFactor = runner.baseFactor ?? runner.speedFactor;
      runner.boosted = false;
      runner.opacity = 1;
      runner.fading = false;
      runner.fadeElapsed = 0;
      runner.fadeDuration = 0;
      if (resetTimer) {
        const base = runner.passDelayBase ?? RACE_OTHER_PASS_DELAY_BASE_MS;
        const jitter = runner.passDelayJitter ?? 0;
        runner.passDelay = base + jitter;
      }
    });
  }

  alignFinalistToHold(runner) {
    if (!runner || runner.holdOffset == null || !this.heroRunner) return;
    const heroCenter = this.heroRunner.x + this.heroRunner.width / 2;
    const desiredCenter = heroCenter + runner.holdOffset;
    runner.x = desiredCenter - runner.width / 2;
  }

  prepareFinishRunners() {
    const schedule = RACE_FINISH_OFFSETS;
    const runners = [this.heroRunner, this.secondRunner, this.thirdRunner];
    runners.forEach((runner, index) => {
      if (!runner) return;
      const baseDelay = schedule[index] ?? schedule[schedule.length - 1];
      runner.runOut = false;
      runner.exited = false;
      runner.launchDelay = baseDelay * 1000;
      runner.runSpeed = this.finishSpeed * (1 - index * 0.04);
      runner.badgeTriggered = false;
    });
  }

  refreshSpeedControl() {
    if (!speedButton) return;
    const canBoost = this.running && this.isBoostableState();
    if (!canBoost) {
      speedButton.disabled = true;
      if (this.speedBoostRemaining <= 0) {
        speedButton.textContent = 'SPEED UP';
      }
      return;
    }
    if (this.speedBoostRemaining > 0) {
      speedButton.disabled = true;
      speedButton.textContent = '加速中！';
    } else {
      speedButton.disabled = false;
      speedButton.textContent = 'SPEED UP';
    }
  }

  isBoostableState() {
    const state = this.sequence[this.stateIndex];
    if (!state) return false;
    return !['goal', 'finish'].includes(state.key);
  }

  update(timestamp) {
    if (!this.running) {
      return;
    }

    const deltaSeconds = Math.min(0.05, (timestamp - this.lastTimestamp) / 1000);
    this.lastTimestamp = timestamp;
    this.stateElapsedMs += deltaSeconds * 1000;
    this.timelineSeconds += deltaSeconds;

    this.updateSpeed(deltaSeconds);

    const currentState = this.sequence[this.stateIndex];
    const stateKey = currentState?.key ?? null;
    let trackSpeed = this.currentSpeed * this.speedMultiplier;

    if (stateKey === 'goal' && currentState) {
      this.updateGoalState(currentState.duration);
      trackSpeed = this.currentSpeed * this.speedMultiplier;
    }

    const runnerSpeed = this.resolveRunnerSpeed(stateKey, trackSpeed);
    this.updateRunners(deltaSeconds, runnerSpeed, stateKey, trackSpeed);

    this.updateBackground(trackSpeed, deltaSeconds);
    this.updateEffects(deltaSeconds);
    this.updateDust(trackSpeed, deltaSeconds);
    this.updateClimax(deltaSeconds, stateKey, trackSpeed);
    this.updateCamera(deltaSeconds);
    this.render();

    if (currentState && this.stateElapsedMs >= currentState.duration && this.canAdvance(currentState.key)) {
      if (this.stateIndex < this.sequence.length - 1) {
        this.stateIndex += 1;
        this.applyStateEntry(this.sequence[this.stateIndex]);
      } else {
        this.completing = true;
      }
    }

    if (this.completing && this.canAdvance('finish')) {
      this.completeRace();
      return;
    }

    if (this.running) {
      this.rafId = requestAnimationFrame(this.update.bind(this));
    }
  }

  updateSpeed(deltaSeconds) {
    if (this.speedBoostRemaining > 0) {
      this.speedBoostRemaining = Math.max(0, this.speedBoostRemaining - deltaSeconds);
      if (this.speedBoostRemaining === 0) {
        this.speedMultiplier = 1;
        this.refreshSpeedControl();
      }
    }
  }

  updateRunners(deltaSeconds, runnerSpeed, stateKey, trackSpeed) {
    const maintainRelative = ['goal', 'lead', 'climax'].includes(stateKey);
    const heroCenterX = this.heroRunner
      ? this.heroRunner.x + this.heroRunner.width / 2
      : 0;
    if (stateKey === 'finish') {
      this.updateFinishState(deltaSeconds);
    } else {
      this.updateFinalistRunner(
        this.thirdRunner,
        deltaSeconds,
        runnerSpeed,
        stateKey,
        maintainRelative,
        trackSpeed,
        heroCenterX
      );
      this.updateFinalistRunner(
        this.secondRunner,
        deltaSeconds,
        runnerSpeed,
        stateKey,
        maintainRelative,
        trackSpeed,
        heroCenterX
      );
    }
    this.updateOthers(
      deltaSeconds,
      runnerSpeed,
      stateKey,
      maintainRelative,
      trackSpeed,
      heroCenterX
    );
  }

  updateOthers(
    deltaSeconds,
    runnerSpeed,
    stateKey,
    maintainRelative,
    trackSpeed,
    heroCenterX
  ) {
    this.otherRunners.forEach((runner) => {
      if (!runner.active) return;
      if (stateKey === 'climax' && this.isClimaxContender(runner)) {
        return;
      }
      if (!runner.allowedToPass && stateKey === 'others' && this.stateElapsedMs >= (runner.passDelay ?? 0)) {
        runner.allowedToPass = true;
      }
      if (!runner.allowedToPass) {
        const offset = runner.packAlignOffset ?? this.passMargin * 1.2;
        const desiredCenter = heroCenterX + offset;
        this.alignRunnerToCenter(runner, desiredCenter, deltaSeconds);
        runner.opacity = 1;
        runner.fading = false;
        runner.fadeElapsed = 0;
        return;
      }
      const dynamicFactor = this.resolveDynamicFactor(runner, stateKey);
      let desired = maintainRelative
        ? this.goalAdjustedRunnerSpeed(dynamicFactor, trackSpeed, runnerSpeed)
        : runnerSpeed * dynamicFactor;
      desired = this.clampRunnerSpeed(desired, trackSpeed);
      runner.x -= desired * deltaSeconds;
      const runnerCenter = runner.x + runner.width / 2;
      if (!runner.passed && runnerCenter <= heroCenterX - this.passMargin) {
        runner.passed = true;
        runner.speedFactor = Math.max(
          0.74,
          (runner.speedFactor ?? dynamicFactor) * 0.9
        );
        runner.baseFactor = runner.speedFactor;
      }
      this.applyRunnerFadeOut(runner, deltaSeconds);
    });
  }

  alignRunnerToCenter(runner, desiredCenter, deltaSeconds) {
    if (!runner) return;
    const currentCenter = runner.x + runner.width / 2;
    const rate = Math.min(1, deltaSeconds * RACE_OTHER_PACK_FOLLOW_RATE);
    runner.x += (desiredCenter - currentCenter) * rate;
  }

  applyRunnerFadeOut(runner, deltaSeconds) {
    if (!runner) return;
    const beyondLeft = runner.x + runner.width < -this.passMargin;
    if (beyondLeft && !runner.fading && !runner.exited) {
      runner.fading = true;
      runner.fadeElapsed = 0;
      runner.fadeDuration = randomRange(
        RACE_OTHER_EXIT_FADE_MS[0],
        RACE_OTHER_EXIT_FADE_MS[1]
      );
    }
    if (runner.fading) {
      runner.fadeElapsed += deltaSeconds * 1000;
      const duration = Math.max(runner.fadeDuration || 1, 1);
      const ratio = Math.min(1, runner.fadeElapsed / duration);
      runner.opacity = Math.max(0, 1 - ratio);
      if (runner.fadeElapsed >= duration) {
        runner.exited = true;
        runner.active = false;
        runner.opacity = 0;
      }
    } else {
      runner.opacity = 1;
    }
  }

  goalAdjustedRunnerSpeed(speedFactor, trackSpeed, defaultSpeed) {
    if (!Number.isFinite(speedFactor) || speedFactor <= 0) {
      return defaultSpeed;
    }
    const blend = RACE_GOAL_RELATIVE_BLEND;
    if (blend <= 0) {
      return defaultSpeed;
    }
    const baselineGround = this.baseSpeed * RACE_PARALLAX_GROUND;
    const baselineRunner = this.baseSpeed * speedFactor;
    const desiredVisible = Math.max(
      this.relativeAdvanceSpeed,
      baselineGround - baselineRunner
    );
    const currentGround = trackSpeed * RACE_PARALLAX_GROUND;
    const denominator = Math.max(speedFactor, 0.0001);
    const compensated = (currentGround - desiredVisible) / denominator;
    const clampedTarget = this.clampRunnerSpeed(compensated, trackSpeed);
    const minSpeed = this.clampRunnerSpeed(defaultSpeed * 0.5, trackSpeed);
    const target = Math.max(minSpeed, clampedTarget);
    if (blend >= 1) {
      return target;
    }
    const blended = defaultSpeed + (target - defaultSpeed) * blend;
    return this.clampRunnerSpeed(Math.max(minSpeed, blended), trackSpeed);
  }

  clampRunnerSpeed(desiredSpeed, trackSpeed) {
    if (!Number.isFinite(desiredSpeed) || desiredSpeed <= 0) {
      return 0;
    }
    const groundSpeed = trackSpeed * RACE_PARALLAX_GROUND;
    if (!Number.isFinite(groundSpeed)) {
      return Math.max(0, desiredSpeed);
    }
    const minAdvance = this.relativeAdvanceSpeed || 0;
    if (groundSpeed <= minAdvance) {
      return Math.max(0, Math.min(desiredSpeed, groundSpeed * 0.6));
    }
    const maxAllowed = Math.max(0, groundSpeed - minAdvance);
    return Math.max(0, Math.min(desiredSpeed, maxAllowed));
  }

  canRunnerOvertake(label, stateKey) {
    switch (label) {
      case 'third':
        return ['third', 'second', 'lead', 'goal', 'finish'].includes(stateKey);
      case 'second':
        return ['second', 'lead', 'goal', 'finish'].includes(stateKey);
      default:
        return true;
    }
  }

  updateFinalistRunner(
    runner,
    deltaSeconds,
    runnerSpeed,
    stateKey,
    maintainRelative,
    trackSpeed,
    heroCenterX
  ) {
    if (!runner || runner.runOut) return;
    const canPass = this.canRunnerOvertake(runner.label, stateKey);
    if (!canPass) {
      const holdOffset =
        runner.holdOffset != null
          ? runner.holdOffset
          : this.passMargin * (runner.label === 'third' ? 0.8 : 1);
      const desiredCenter = heroCenterX + holdOffset;
      this.alignRunnerToCenter(runner, desiredCenter, deltaSeconds);
      runner.passed = false;
      return;
    }
    const dynamicFactor = this.resolveDynamicFactor(runner, stateKey);
    let desired = maintainRelative
      ? this.goalAdjustedRunnerSpeed(dynamicFactor, trackSpeed, runnerSpeed)
      : runnerSpeed * dynamicFactor;
    desired = this.clampRunnerSpeed(desired, trackSpeed);
    runner.x -= desired * deltaSeconds;
    const runnerCenter = runner.x + runner.width / 2;
    if (!runner.passed && runnerCenter <= heroCenterX - this.passMargin) {
      runner.passed = true;
      runner.speedFactor = Math.min(1.05, Math.max(0.9, runner.speedFactor ?? dynamicFactor));
      runner.baseFactor = runner.speedFactor;
    }
    if (runner.x + runner.width < -this.passMargin) {
      runner.exited = true;
    }
  }

  updateGoalState(duration) {
    if (!this.goal || !this.goal.active) return;
    const progress = Math.min(1, this.stateElapsedMs / duration);
    const eased = easeInQuad(progress);
    this.goal.progress = eased;
    this.goal.x = this.goal.startX + (this.goal.targetX - this.goal.startX) * eased;
    const remaining = Math.max(0, 1 - eased);
    const goalBase = this.baseSpeed * (RACE_STATE_SPEED_FACTORS.goal ?? 1);
    this.currentSpeed = goalBase * remaining;
    if (progress >= 1) {
      this.goal.stopped = true;
    }
  }

  updateFinishState(deltaSeconds) {
    const runners = [this.heroRunner, this.secondRunner, this.thirdRunner];
    runners.forEach((runner) => {
      if (!runner) return;
      if (!runner.runOut && this.stateElapsedMs >= runner.launchDelay) {
        runner.runOut = true;
      }
      if (runner.runOut) {
        runner.x += runner.runSpeed * deltaSeconds;
        const runnerCenter = runner.x + runner.width / 2;
      if (
          !runner.badgeTriggered &&
          runner.rankIndex != null &&
          runnerCenter >= this.goalCenterX
        ) {
        markTekichuBadge(runner.rankIndex);
        if (runner.rankIndex === 0) {
          this.triggerPhotoFinish();
        }
        runner.badgeTriggered = true;
      }
        if (runner.x > this.stageWidth + this.passMargin * 2) {
          runner.exited = true;
        }
      }
    });
  }

  updateBackground(effectiveSpeed, deltaSeconds) {
    this.backgroundOffsets.sky += effectiveSpeed * RACE_PARALLAX_SKY * deltaSeconds;
    this.backgroundOffsets.bloom += effectiveSpeed * RACE_PARALLAX_SAKU * deltaSeconds;
    this.backgroundOffsets.ground += effectiveSpeed * RACE_PARALLAX_GROUND * deltaSeconds;
    if (this.markerSpacing > 0) {
      this.distanceMarkerOffset =
        (this.distanceMarkerOffset +
          effectiveSpeed * RACE_PARALLAX_GROUND * deltaSeconds) % this.markerSpacing;
    }
  }

  updateDust(trackSpeed, deltaSeconds) {
    const groundSpeed = Math.max(trackSpeed * RACE_PARALLAX_GROUND, 0);
    const spawnRate = RACE_DUST_BASE_RATE * this.dustRateMultiplier;
    this.dustAccumulator += spawnRate * deltaSeconds;
    while (this.dustAccumulator >= 1) {
      this.spawnDustParticle(groundSpeed);
      this.dustAccumulator -= 1;
    }
    this.dustParticles = this.dustParticles
      .map((particle) => {
        const lifeMs = particle.life - deltaSeconds * 1000;
        if (lifeMs <= 0) {
          return null;
        }
        const dx = (groundSpeed + particle.speedOffset) * deltaSeconds;
        return {
          ...particle,
          x: particle.x - dx,
          life: lifeMs
        };
      })
      .filter(Boolean)
      .slice(-RACE_DUST_MAX);
  }

  spawnDustParticle(groundSpeed) {
    if (!this.heroRunner) return;
    const groundTop = this.stageHeight - this.getGroundHeight();
    const size = randomRange(RACE_DUST_SIZE[0], RACE_DUST_SIZE[1]);
    const heroFootY = this.heroRunner.y + this.heroRunner.height - size * 0.2;
    const lifetime = randomRange(RACE_DUST_LIFETIME[0], RACE_DUST_LIFETIME[1]);
    const offsetX = randomRange(-32, 16) * this.stageScale;
    this.dustParticles.push({
      x: this.heroRunner.x + this.heroRunner.width + offsetX,
      y: Math.min(groundTop + size * 0.5, heroFootY),
      size,
      life: lifetime,
      maxLife: lifetime,
      speedOffset: randomRange(groundSpeed * 0.05, groundSpeed * 0.18)
    });
  }

  updateClimax(deltaSeconds, stateKey, trackSpeed) {
    if (!this.climaxActive || stateKey !== 'climax') {
      return;
    }
    const deltaMs = deltaSeconds * 1000;
    this.climaxTimer += deltaMs;
    this.queueDistanceTelops(deltaMs);
    this.updateDistanceTelops(deltaMs);
    if (!this.climaxShakeTriggered && this.climaxTimer >= this.climaxDurationMs * 0.7) {
      this.startShake(RACE_CLIMAX_SHAKE);
      this.climaxShakeTriggered = true;
    }

    const bobAmount = this.stageToCanvasY(RACE_CLIMAX_VERTICAL_BOB);
    const applyBob = (runner) => {
      if (!runner) return;
      const phase = this.timelineSeconds * 4 + (runner.wavePhase ?? 0);
      runner.visualOffsetY = Math.sin(phase) * bobAmount;
    };
    applyBob(this.heroRunner);
    applyBob(this.secondRunner);
    applyBob(this.thirdRunner);
    if (this.otherRunners) {
      this.otherRunners.forEach((runner) => applyBob(runner));
    }

    if (this.climaxReliefTimer > 0) {
      this.climaxReliefTimer = Math.max(0, this.climaxReliefTimer - deltaMs);
    }
    const heroCenter = this.heroRunner
      ? this.heroRunner.x + this.heroRunner.width / 2
      : 0;
    this.updateClimaxContenders(deltaSeconds, heroCenter);
  }

  updateCamera(deltaSeconds) {
    if (!this.shakeConfig) return;
    const { amplitude, duration, repeats } = this.shakeConfig;
    if (duration <= 0 || repeats <= 0) {
      this.setTrackShake(0, 0);
      this.shakeConfig = null;
      return;
    }
    this.shakeTimer += deltaSeconds;
    this.shakeTotal += deltaSeconds;
    if (this.shakeTotal >= duration * repeats) {
      this.setTrackShake(0, 0);
      this.shakeConfig = null;
      return;
    }
    const progress = (this.shakeTimer % duration) / duration;
    const angle = progress * Math.PI * 2;
    const shakeX = Math.sin(angle) * amplitude;
    const shakeY = Math.cos(angle) * amplitude * 0.5;
    this.setTrackShake(shakeX, shakeY);
  }

  resolveRunnerSpeed(stateKey, trackSpeed) {
    return trackSpeed;
  }

  resolveDynamicFactor(runner, stateKey) {
    if (!runner) return 1;
    let factor = runner.speedFactor ?? 1;
    const paceTable = RACE_PACE_MODIFIERS[stateKey];
    if (paceTable && runner.legType && paceTable[runner.legType] != null) {
      factor *= paceTable[runner.legType];
    }
    const amplitude = runner.waveAmplitude ?? 0;
    if (!runner.fixed && amplitude > 0) {
      const frequency = runner.waveFrequency ?? RACE_SURGE_FREQUENCY;
      const phase = runner.wavePhase ?? 0;
      const wave = Math.sin((this.timelineSeconds * frequency + phase) * Math.PI * 2);
      factor += wave * amplitude;
    }
    if (stateKey === 'climax' && runner.legType) {
      const pulseFreq = RACE_CLIMAX_PULSE_FREQ[runner.legType] ?? 2.4;
      const pulseAmp = RACE_CLIMAX_PULSE_AMP[runner.legType] ?? 0.05;
      const pulse = Math.sin((this.timelineSeconds * pulseFreq + (runner.wavePhase ?? 0)) * Math.PI * 2);
      factor *= 1 + pulse * pulseAmp;
    }
    if (runner.boosted) {
      factor += 0.06;
    }
    if (!runner.fixed && this.speedMultiplier > 1 && this.isBoostableState()) {
      const boost = this.speedMultiplier - 1;
      const relief = this.afterStraight
        ? RACE_SPEEDUP_STRAIGHT_RELIEF
        : RACE_SPEEDUP_RELIEF;
      const sensitivity = runner.boostSensitivity ?? 1;
      factor -= boost * relief * sensitivity;
    }
    if (stateKey === 'climax' && this.climaxReliefDuration > 0) {
      const reliefRatio = this.climaxReliefTimer > 0 ? this.climaxReliefTimer / this.climaxReliefDuration : 0;
      if (runner.label === 'hero') {
        factor += RACE_CLIMAX_HERO_BOOST * reliefRatio;
      } else if (!runner.fixed) {
        const relief = RACE_CLIMAX_OTHERS_RELIEF * reliefRatio * (runner.boostSensitivity ?? 1);
        factor -= relief;
      }
    }
    if (runner.runOut) {
      return Math.max(RACE_MIN_SPEED_FACTOR, Math.min(RACE_MAX_SPEED_FACTOR, factor));
    }
    return Math.max(RACE_MIN_SPEED_FACTOR, Math.min(RACE_MAX_SPEED_FACTOR, factor));
  }

  render() {
    if (!this.ctx) return;
    this.ctx.clearRect(0, 0, this.stageWidth, this.stageHeight);
    this.drawBackground();
    this.drawDistanceMarkers();
    this.drawDust();
    this.drawRunners();
    this.drawGoal();
    this.drawPhotoFinish();
  }

  drawBackground() {
    const skyImg = this.resolveImage(RACE_ASSET_PATHS.sky);
    const bloomImg = this.resolveImage(RACE_ASSET_PATHS.bloom);
    const groundImg = this.resolveImage(RACE_ASSET_PATHS.ground);
    const groundHeight = this.getGroundHeight();
    const bloomHeight = RACE_BACKGROUND_BLOOM_HEIGHT * this.stageScale;
    const skyHeight = Math.max(this.stageHeight - groundHeight, RACE_BACKGROUND_SKY_HEIGHT * this.stageScale);
    const groundTop = this.stageHeight - groundHeight;
    const bloomTop = groundTop - bloomHeight;

    if (skyImg) {
      this.drawTiledLayer(skyImg, 0, skyHeight, this.backgroundOffsets.sky);
    } else {
      this.ctx.fillStyle = '#b9e2ff';
      this.ctx.fillRect(0, 0, this.stageWidth, skyHeight);
    }

    if (bloomImg) {
      this.drawTiledLayer(bloomImg, bloomTop, bloomHeight, this.backgroundOffsets.bloom);
    }

    if (groundImg) {
      this.drawTiledLayer(groundImg, groundTop, groundHeight, this.backgroundOffsets.ground);
    } else {
      this.ctx.fillStyle = '#9ed9a3';
      this.ctx.fillRect(0, groundTop, this.stageWidth, groundHeight);
    }
  }

  drawTiledLayer(image, top, height, offset) {
    const aspect = image && image.height ? image.width / image.height : 1;
    const width = height * aspect;
    if (width <= 0) return;
    let x = -((offset % width) || 0);
    if (x > 0) {
      x -= width;
    }
    while (x < this.stageWidth) {
      this.ctx.drawImage(image, x, top, width, height);
      x += width;
    }
  }

  drawDistanceMarkers() {
    if (!this.ctx || !this.markerSpacing || this.markerSpacing <= 0) return;
    const groundHeight = this.getGroundHeight();
    const groundTop = this.stageHeight - groundHeight;
    const markerHeight = this.markerHeight || groundHeight * 0.25;
    const markerWidth = this.markerWidth || 6;
    const upper = groundTop - markerHeight;
    let x = -this.distanceMarkerOffset;
    while (x < this.stageWidth + this.markerSpacing) {
      const drawX = x - markerWidth / 2;
      this.ctx.fillStyle = RACE_DISTANCE_MARKER_BASE;
      this.ctx.fillRect(drawX, upper + markerHeight * 0.3, markerWidth, markerHeight * 0.7);
      this.ctx.fillStyle = RACE_DISTANCE_MARKER_COLOR;
      this.ctx.fillRect(drawX, upper, markerWidth, markerHeight);
      x += this.markerSpacing;
    }
  }

  drawDust() {
    if (!this.ctx || !this.dustParticles.length) return;
    this.dustParticles.forEach((particle) => {
      const lifeRatio = Math.max(0, Math.min(1, particle.life / particle.maxLife));
      const alpha = Math.min(0.4, 0.15 + (1 - lifeRatio) * 0.25);
      const size = particle.size * this.stageScale;
      this.ctx.save();
      this.ctx.globalAlpha = alpha;
      const gradient = this.ctx.createRadialGradient(
        particle.x,
        particle.y,
        0,
        particle.x,
        particle.y,
        size
      );
      gradient.addColorStop(0, 'rgba(255, 248, 220, 0.8)');
      gradient.addColorStop(1, 'rgba(255, 248, 220, 0)');
      this.ctx.fillStyle = gradient;
      this.ctx.beginPath();
      this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
      this.ctx.fill();
      this.ctx.restore();
    });
  }

  drawRunners() {
    const runners = [];
    this.otherRunners.forEach((runner) => {
      if (runner.spawned && !runner.exited) {
        runners.push(runner);
      }
    });
    [this.thirdRunner, this.secondRunner, this.heroRunner].forEach((runner) => {
      if (runner && !runner.exited) {
        runners.push(runner);
      }
    });
    runners.sort((a, b) => a.y + a.height - (b.y + b.height));
    runners.forEach((runner) => {
      if (!runner.image) return;
      const drawX = runner.x + (runner.visualOffsetX || 0);
      const drawY = runner.y + (runner.visualOffsetY || 0);
      const opacity = runner.opacity != null ? runner.opacity : 1;
      if (opacity <= 0) {
        return;
      }
      this.ctx.save();
      this.ctx.globalAlpha = Math.max(0, Math.min(1, opacity));
      if (runner.label === 'hero') {
        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.75)';
        this.ctx.shadowBlur = this.stageToCanvasX(6);
      }
      this.ctx.drawImage(runner.image, drawX, drawY, runner.width, runner.height);
      this.ctx.restore();
    });
  }

  drawGoal() {
    if (!this.goal || !this.goal.active || !this.goal.image) return;
    const x = this.goal.x - this.goal.width / 2;
    this.ctx.drawImage(this.goal.image, x, this.goal.y, this.goal.width, this.goal.height);
  }

  drawPhotoFinish() {
    if (!this.photoFinishActive || this.photoFinishTimer <= 0) return;
    const ratio = this.photoFinishTimer / RACE_PHOTO_LINE_DURATION_MS;
    const alpha = Math.max(0, Math.min(1, ratio));
    const lineWidth = Math.max(2, this.stageToCanvasX(4));
    this.ctx.save();
    this.ctx.globalAlpha = alpha;
    this.ctx.fillStyle = '#ffffff';
    this.ctx.fillRect(this.goalCenterX - lineWidth / 2, 0, lineWidth, this.stageHeight);
    this.ctx.restore();
  }

  createRunner(horse, options = {}) {
    const data = horse || createPlaceholderHorse(options.label || 'runner');
    const image = this.resolveImage(data.img);
    const height = this.runnerHeight;
    const aspect = image && image.height ? image.width / image.height : 1;
    const width = height * aspect;
    const groundTop = this.stageHeight - this.getGroundHeight();
    const defaultX = options.x ?? this.stageWidth + width;
    const defaultY = options.y ?? groundTop - height;
    return {
      horse: data,
      image,
      x: defaultX,
      y: defaultY,
      baseX: defaultX,
      baseY: defaultY,
      width,
      height,
      speedFactor: options.speedFactor ?? 1,
      baseFactor: options.speedFactor ?? 1,
      active: options.active ?? true,
      spawnTime: options.spawnTime ?? 0,
      spawned: options.active ?? true,
      passed: false,
      exited: false,
      fixed: options.fixed ?? false,
      runOut: false,
      launchDelay: 0,
      runSpeed: this.finishSpeed,
      label: options.label ?? 'runner',
      rankIndex: options.rankIndex ?? null,
      badgeTriggered: false,
      allowedToPass: options.allowedToPass ?? true,
      packAlignOffset: options.packAlignOffset ?? 0,
      passDelay: options.passDelay ?? 0,
      passDelayBase: options.passDelayBase ?? 0,
      passDelayJitter: options.passDelayJitter ?? 0,
      holdOffset: options.holdOffset ?? null,
      laneIndex: options.laneIndex ?? null,
      rowIndex: options.rowIndex ?? null,
      slotIndex: options.slotIndex ?? null,
      legType: options.legType ?? 'front',
      wavePhase: options.wavePhase ?? Math.random() * Math.PI * 2,
      waveAmplitude: options.waveAmplitude ?? (options.fixed ? 0 : RACE_SURGE_AMPLITUDE),
      waveFrequency: options.waveFrequency ?? RACE_SURGE_FREQUENCY,
      boostSensitivity: options.boostSensitivity ?? (options.fixed ? 0 : 1),
      boosted: options.boosted ?? false,
      visualOffsetX: 0,
      visualOffsetY: 0,
      opacity: 1,
      fading: false,
      fadeElapsed: 0,
      fadeDuration: 0
    };
  }

  resolveImage(path) {
    if (path && raceAssetCache.has(path)) {
      return raceAssetCache.get(path);
    }
    if (raceAssetCache.has(placeholderHorseSrc)) {
      return raceAssetCache.get(placeholderHorseSrc);
    }
    return null;
  }

  getGroundHeight() {
    return Math.max(0, RACE_BACKGROUND_GROUND_HEIGHT * this.stageScale);
  }

  stageToCanvasX(value) {
    return (value / STAGE_RATIO_W) * this.stageWidth;
  }

  stageToCanvasY(value) {
    return (value / RACE_STAGE_BASE_HEIGHT) * this.stageHeight;
  }

  toCanvasX(value) {
    return (value / RACE_VIRTUAL_WIDTH) * this.stageWidth;
  }

  toCanvasY(value) {
    return (value / RACE_VIRTUAL_HEIGHT) * this.stageHeight;
  }

  toCanvasSpeed(value) {
    return (value / RACE_VIRTUAL_WIDTH) * this.stageWidth;
  }

  canAdvance(stateKey) {
    switch (stateKey) {
      case 'others':
        return this.otherRunners.every((runner) => !runner.spawned || runner.passed);
      case 'third':
        return !this.thirdRunner || this.thirdRunner.passed;
      case 'second':
        return !this.secondRunner || this.secondRunner.passed;
      case 'goal':
        return this.goal ? this.goal.stopped : true;
      case 'finish':
        return [this.heroRunner, this.secondRunner, this.thirdRunner]
          .filter(Boolean)
          .every((runner) => runner.exited);
      default:
        return true;
    }
  }

  triggerSpeedUp() {
    if (!this.running || !this.isBoostableState() || this.speedBoostRemaining > 0) {
      return;
    }
    const straightBonus = this.afterStraight ? RACE_SPEEDUP_STRAIGHT_BONUS : 1;
    this.speedMultiplier = SPEED_UP_MULTIPLIER * straightBonus;
    this.speedBoostRemaining = SPEED_UP_DURATION_MS / 1000;
    this.refreshSpeedControl();
    const stateKey = this.sequence[this.stateIndex]?.key;
    if (stateKey === 'climax') {
      this.activateClimaxBoost();
    }
  }

  completeRace() {
    if (!this.running) return;
    this.running = false;
    this.refreshSpeedControl();
    if (this.rafId !== null) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
    setTimeout(() => {
      finishRace();
    }, 400);
  }
}

function loadImage(src) {
  return new Promise((resolve) => {
    const image = new Image();
    image.decoding = 'async';
    image.onload = () => resolve([src, image]);
    image.onerror = (error) => {
      console.warn('[race] 画像の読み込みに失敗しました', src, error);
      resolve([src, null]);
    };
    image.src = src;
  });
}

function easeOutQuad(t) {
  return 1 - (1 - t) * (1 - t);
}

function easeInQuad(t) {
  return t * t;
}

function shuffleArray(source) {
  const array = Array.isArray(source) ? [...source] : [];
  for (let i = array.length - 1; i > 0; i -= 1) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

function randomRange(min, max) {
  if (!Number.isFinite(min) || !Number.isFinite(max)) return min || 0;
  if (min > max) [min, max] = [max, min];
  return min + Math.random() * (max - min);
}

function finishRace() {
  populateResult();
  switchScreen('result');
}

function populateResult() {
  resultList.innerHTML = '';
  selectedOrder.forEach((horseId, index) => {
    const horse = horses.find((h) => h.id === horseId);
    if (!horse) return;
    const item = document.createElement('li');
    item.className = 'result-item';
    const crown = document.createElement('img');
    crown.className = 'result-crown';
    crown.src = crownImages[index] || crownImages[crownImages.length - 1];
    crown.alt = `${index + 1}着の王冠アイコン`;
    const img = document.createElement('img');
    img.className = 'result-horse';
    img.src = horse.img;
    img.alt = `${horse.name}のアイコン`;
    const rank = document.createElement('span');
    rank.className = 'result-rank';
    rank.textContent = `${index + 1}着`;
    const nameWrap = document.createElement('span');
    nameWrap.className = 'result-name';
    if (horse.resultNameImg) {
      const nameImg = document.createElement('img');
      nameImg.className = 'result-name-img';
      nameImg.src = horse.resultNameImg;
      nameImg.alt = '';
      nameImg.setAttribute('aria-hidden', 'true');
      nameWrap.append(nameImg);
      const srText = document.createElement('span');
      srText.className = 'sr-only';
      srText.textContent = horse.name;
      nameWrap.append(srText);
    } else {
      nameWrap.textContent = horse.name;
    }
    item.append(crown, img, nameWrap, rank);
    resultList.append(item);
  });
}

// ---------------------------------------------
// 補助：スクリーン切替でスクロール位置を調整
// ---------------------------------------------
const observer = new MutationObserver(() => {
  if (!app) return;
  app.scrollTo({ top: 0, behavior: 'smooth' });
});
observer.observe(app, { attributes: true, attributeFilter: ['data-screen'] });
</script>
</body>
</html>